// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package transport

import (
	"context"
	"github.com/SherClockHolmes/webpush-go"
	"github.com/nakamauwu/nakama"
	"io"
	"net/url"
	"sync"
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//	func TestSomethingThatUsesService(t *testing.T) {
//
//		// make and configure a mocked Service
//		mockedService := &ServiceMock{
//			AddWebPushSubscriptionFunc: func(ctx context.Context, sub webpush.Subscription) error {
//				panic("mock out the AddWebPushSubscription method")
//			},
//			AuthUserFunc: func(ctx context.Context) (nakama.User, error) {
//				panic("mock out the AuthUser method")
//			},
//			AuthUserIDFromTokenFunc: func(token string) (string, error) {
//				panic("mock out the AuthUserIDFromToken method")
//			},
//			CommentStreamFunc: func(ctx context.Context, postID string) (<-chan nakama.Comment, error) {
//				panic("mock out the CommentStream method")
//			},
//			CommentsFunc: func(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error) {
//				panic("mock out the Comments method")
//			},
//			CreateCommentFunc: func(ctx context.Context, postID string, content string) (nakama.Comment, error) {
//				panic("mock out the CreateComment method")
//			},
//			CreateTimelineItemFunc: func(ctx context.Context, content string, spoilerOf *string, nsfw bool, media []io.ReadSeeker) (nakama.TimelineItem, error) {
//				panic("mock out the CreateTimelineItem method")
//			},
//			DeleteCommentFunc: func(ctx context.Context, commentID string) error {
//				panic("mock out the DeleteComment method")
//			},
//			DeletePostFunc: func(ctx context.Context, postID string) error {
//				panic("mock out the DeletePost method")
//			},
//			DeleteTimelineItemFunc: func(ctx context.Context, timelineItemID string) error {
//				panic("mock out the DeleteTimelineItem method")
//			},
//			DevLoginFunc: func(ctx context.Context, email string) (nakama.AuthOutput, error) {
//				panic("mock out the DevLogin method")
//			},
//			FolloweesFunc: func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
//				panic("mock out the Followees method")
//			},
//			FollowersFunc: func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
//				panic("mock out the Followers method")
//			},
//			HasUnreadNotificationsFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the HasUnreadNotifications method")
//			},
//			LoginFromProviderFunc: func(ctx context.Context, name string, user nakama.ProvidedUser) (nakama.User, error) {
//				panic("mock out the LoginFromProvider method")
//			},
//			MarkNotificationAsReadFunc: func(ctx context.Context, notificationID string) error {
//				panic("mock out the MarkNotificationAsRead method")
//			},
//			MarkNotificationsAsReadFunc: func(ctx context.Context) error {
//				panic("mock out the MarkNotificationsAsRead method")
//			},
//			NotificationStreamFunc: func(ctx context.Context) (<-chan nakama.Notification, error) {
//				panic("mock out the NotificationStream method")
//			},
//			NotificationsFunc: func(ctx context.Context, last uint64, before *string) (nakama.Notifications, error) {
//				panic("mock out the Notifications method")
//			},
//			ParseRedirectURIFunc: func(rawurl string) (*url.URL, error) {
//				panic("mock out the ParseRedirectURI method")
//			},
//			PostFunc: func(ctx context.Context, postID string) (nakama.Post, error) {
//				panic("mock out the Post method")
//			},
//			PostStreamFunc: func(ctx context.Context) (<-chan nakama.Post, error) {
//				panic("mock out the PostStream method")
//			},
//			PostsFunc: func(ctx context.Context, last uint64, before *string, opts ...nakama.PostsOpt) (nakama.Posts, error) {
//				panic("mock out the Posts method")
//			},
//			SendMagicLinkFunc: func(ctx context.Context, in nakama.SendMagicLink) error {
//				panic("mock out the SendMagicLink method")
//			},
//			TimelineFunc: func(ctx context.Context, last uint64, before *string) (nakama.Timeline, error) {
//				panic("mock out the Timeline method")
//			},
//			TimelineItemStreamFunc: func(ctx context.Context) (<-chan nakama.TimelineItem, error) {
//				panic("mock out the TimelineItemStream method")
//			},
//			ToggleCommentReactionFunc: func(ctx context.Context, commentID string, in nakama.ReactionInput) ([]nakama.Reaction, error) {
//				panic("mock out the ToggleCommentReaction method")
//			},
//			ToggleFollowFunc: func(ctx context.Context, username string) (nakama.ToggleFollowOutput, error) {
//				panic("mock out the ToggleFollow method")
//			},
//			TogglePostReactionFunc: func(ctx context.Context, postID string, in nakama.ReactionInput) ([]nakama.Reaction, error) {
//				panic("mock out the TogglePostReaction method")
//			},
//			TogglePostSubscriptionFunc: func(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error) {
//				panic("mock out the TogglePostSubscription method")
//			},
//			TokenFunc: func(ctx context.Context) (nakama.TokenOutput, error) {
//				panic("mock out the Token method")
//			},
//			UpdateAvatarFunc: func(ctx context.Context, r io.ReadSeeker) (string, error) {
//				panic("mock out the UpdateAvatar method")
//			},
//			UpdateCoverFunc: func(ctx context.Context, r io.ReadSeeker) (string, error) {
//				panic("mock out the UpdateCover method")
//			},
//			UpdateUserFunc: func(ctx context.Context, params nakama.UpdateUserParams) error {
//				panic("mock out the UpdateUser method")
//			},
//			UserFunc: func(ctx context.Context, username string) (nakama.UserProfile, error) {
//				panic("mock out the User method")
//			},
//			UsernamesFunc: func(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error) {
//				panic("mock out the Usernames method")
//			},
//			UsersFunc: func(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error) {
//				panic("mock out the Users method")
//			},
//			VerifyMagicLinkFunc: func(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error) {
//				panic("mock out the VerifyMagicLink method")
//			},
//		}
//
//		// use mockedService in code that requires Service
//		// and then make assertions.
//
//	}
type ServiceMock struct {
	// AddWebPushSubscriptionFunc mocks the AddWebPushSubscription method.
	AddWebPushSubscriptionFunc func(ctx context.Context, sub webpush.Subscription) error

	// AuthUserFunc mocks the AuthUser method.
	AuthUserFunc func(ctx context.Context) (nakama.User, error)

	// AuthUserIDFromTokenFunc mocks the AuthUserIDFromToken method.
	AuthUserIDFromTokenFunc func(token string) (string, error)

	// CommentStreamFunc mocks the CommentStream method.
	CommentStreamFunc func(ctx context.Context, postID string) (<-chan nakama.Comment, error)

	// CommentsFunc mocks the Comments method.
	CommentsFunc func(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error)

	// CreateCommentFunc mocks the CreateComment method.
	CreateCommentFunc func(ctx context.Context, postID string, content string) (nakama.Comment, error)

	// CreateTimelineItemFunc mocks the CreateTimelineItem method.
	CreateTimelineItemFunc func(ctx context.Context, content string, spoilerOf *string, nsfw bool, media []io.ReadSeeker) (nakama.TimelineItem, error)

	// DeleteCommentFunc mocks the DeleteComment method.
	DeleteCommentFunc func(ctx context.Context, commentID string) error

	// DeletePostFunc mocks the DeletePost method.
	DeletePostFunc func(ctx context.Context, postID string) error

	// DeleteTimelineItemFunc mocks the DeleteTimelineItem method.
	DeleteTimelineItemFunc func(ctx context.Context, timelineItemID string) error

	// DevLoginFunc mocks the DevLogin method.
	DevLoginFunc func(ctx context.Context, email string) (nakama.AuthOutput, error)

	// FolloweesFunc mocks the Followees method.
	FolloweesFunc func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error)

	// FollowersFunc mocks the Followers method.
	FollowersFunc func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error)

	// HasUnreadNotificationsFunc mocks the HasUnreadNotifications method.
	HasUnreadNotificationsFunc func(ctx context.Context) (bool, error)

	// LoginFromProviderFunc mocks the LoginFromProvider method.
	LoginFromProviderFunc func(ctx context.Context, name string, user nakama.ProvidedUser) (nakama.User, error)

	// MarkNotificationAsReadFunc mocks the MarkNotificationAsRead method.
	MarkNotificationAsReadFunc func(ctx context.Context, notificationID string) error

	// MarkNotificationsAsReadFunc mocks the MarkNotificationsAsRead method.
	MarkNotificationsAsReadFunc func(ctx context.Context) error

	// NotificationStreamFunc mocks the NotificationStream method.
	NotificationStreamFunc func(ctx context.Context) (<-chan nakama.Notification, error)

	// NotificationsFunc mocks the Notifications method.
	NotificationsFunc func(ctx context.Context, last uint64, before *string) (nakama.Notifications, error)

	// ParseRedirectURIFunc mocks the ParseRedirectURI method.
	ParseRedirectURIFunc func(rawurl string) (*url.URL, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, postID string) (nakama.Post, error)

	// PostStreamFunc mocks the PostStream method.
	PostStreamFunc func(ctx context.Context) (<-chan nakama.Post, error)

	// PostsFunc mocks the Posts method.
	PostsFunc func(ctx context.Context, last uint64, before *string, opts ...nakama.PostsOpt) (nakama.Posts, error)

	// SendMagicLinkFunc mocks the SendMagicLink method.
	SendMagicLinkFunc func(ctx context.Context, in nakama.SendMagicLink) error

	// TimelineFunc mocks the Timeline method.
	TimelineFunc func(ctx context.Context, last uint64, before *string) (nakama.Timeline, error)

	// TimelineItemStreamFunc mocks the TimelineItemStream method.
	TimelineItemStreamFunc func(ctx context.Context) (<-chan nakama.TimelineItem, error)

	// ToggleCommentReactionFunc mocks the ToggleCommentReaction method.
	ToggleCommentReactionFunc func(ctx context.Context, commentID string, in nakama.ReactionInput) ([]nakama.Reaction, error)

	// ToggleFollowFunc mocks the ToggleFollow method.
	ToggleFollowFunc func(ctx context.Context, username string) (nakama.ToggleFollowOutput, error)

	// TogglePostReactionFunc mocks the TogglePostReaction method.
	TogglePostReactionFunc func(ctx context.Context, postID string, in nakama.ReactionInput) ([]nakama.Reaction, error)

	// TogglePostSubscriptionFunc mocks the TogglePostSubscription method.
	TogglePostSubscriptionFunc func(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error)

	// TokenFunc mocks the Token method.
	TokenFunc func(ctx context.Context) (nakama.TokenOutput, error)

	// UpdateAvatarFunc mocks the UpdateAvatar method.
	UpdateAvatarFunc func(ctx context.Context, r io.ReadSeeker) (string, error)

	// UpdateCoverFunc mocks the UpdateCover method.
	UpdateCoverFunc func(ctx context.Context, r io.ReadSeeker) (string, error)

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, params nakama.UpdateUserParams) error

	// UserFunc mocks the User method.
	UserFunc func(ctx context.Context, username string) (nakama.UserProfile, error)

	// UsernamesFunc mocks the Usernames method.
	UsernamesFunc func(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error)

	// UsersFunc mocks the Users method.
	UsersFunc func(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error)

	// VerifyMagicLinkFunc mocks the VerifyMagicLink method.
	VerifyMagicLinkFunc func(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddWebPushSubscription holds details about calls to the AddWebPushSubscription method.
		AddWebPushSubscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sub is the sub argument value.
			Sub webpush.Subscription
		}
		// AuthUser holds details about calls to the AuthUser method.
		AuthUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// AuthUserIDFromToken holds details about calls to the AuthUserIDFromToken method.
		AuthUserIDFromToken []struct {
			// Token is the token argument value.
			Token string
		}
		// CommentStream holds details about calls to the CommentStream method.
		CommentStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// Comments holds details about calls to the Comments method.
		Comments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// CreateComment holds details about calls to the CreateComment method.
		CreateComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
			// Content is the content argument value.
			Content string
		}
		// CreateTimelineItem holds details about calls to the CreateTimelineItem method.
		CreateTimelineItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Content is the content argument value.
			Content string
			// SpoilerOf is the spoilerOf argument value.
			SpoilerOf *string
			// Nsfw is the nsfw argument value.
			Nsfw bool
			// Media is the media argument value.
			Media []io.ReadSeeker
		}
		// DeleteComment holds details about calls to the DeleteComment method.
		DeleteComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID string
		}
		// DeletePost holds details about calls to the DeletePost method.
		DeletePost []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// DeleteTimelineItem holds details about calls to the DeleteTimelineItem method.
		DeleteTimelineItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TimelineItemID is the timelineItemID argument value.
			TimelineItemID string
		}
		// DevLogin holds details about calls to the DevLogin method.
		DevLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// Followees holds details about calls to the Followees method.
		Followees []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// Followers holds details about calls to the Followers method.
		Followers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// HasUnreadNotifications holds details about calls to the HasUnreadNotifications method.
		HasUnreadNotifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LoginFromProvider holds details about calls to the LoginFromProvider method.
		LoginFromProvider []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// User is the user argument value.
			User nakama.ProvidedUser
		}
		// MarkNotificationAsRead holds details about calls to the MarkNotificationAsRead method.
		MarkNotificationAsRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NotificationID is the notificationID argument value.
			NotificationID string
		}
		// MarkNotificationsAsRead holds details about calls to the MarkNotificationsAsRead method.
		MarkNotificationsAsRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NotificationStream holds details about calls to the NotificationStream method.
		NotificationStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Notifications holds details about calls to the Notifications method.
		Notifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// ParseRedirectURI holds details about calls to the ParseRedirectURI method.
		ParseRedirectURI []struct {
			// Rawurl is the rawurl argument value.
			Rawurl string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// PostStream holds details about calls to the PostStream method.
		PostStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Posts holds details about calls to the Posts method.
		Posts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
			// Opts is the opts argument value.
			Opts []nakama.PostsOpt
		}
		// SendMagicLink holds details about calls to the SendMagicLink method.
		SendMagicLink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In nakama.SendMagicLink
		}
		// Timeline holds details about calls to the Timeline method.
		Timeline []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// TimelineItemStream holds details about calls to the TimelineItemStream method.
		TimelineItemStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ToggleCommentReaction holds details about calls to the ToggleCommentReaction method.
		ToggleCommentReaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID string
			// In is the in argument value.
			In nakama.ReactionInput
		}
		// ToggleFollow holds details about calls to the ToggleFollow method.
		ToggleFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// TogglePostReaction holds details about calls to the TogglePostReaction method.
		TogglePostReaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
			// In is the in argument value.
			In nakama.ReactionInput
		}
		// TogglePostSubscription holds details about calls to the TogglePostSubscription method.
		TogglePostSubscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// Token holds details about calls to the Token method.
		Token []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateAvatar holds details about calls to the UpdateAvatar method.
		UpdateAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R io.ReadSeeker
		}
		// UpdateCover holds details about calls to the UpdateCover method.
		UpdateCover []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R io.ReadSeeker
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params nakama.UpdateUserParams
		}
		// User holds details about calls to the User method.
		User []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// Usernames holds details about calls to the Usernames method.
		Usernames []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StartingWith is the startingWith argument value.
			StartingWith string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// Users holds details about calls to the Users method.
		Users []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Search is the search argument value.
			Search string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// VerifyMagicLink holds details about calls to the VerifyMagicLink method.
		VerifyMagicLink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Code is the code argument value.
			Code string
			// Username is the username argument value.
			Username *string
		}
	}
	lockAddWebPushSubscription  sync.RWMutex
	lockAuthUser                sync.RWMutex
	lockAuthUserIDFromToken     sync.RWMutex
	lockCommentStream           sync.RWMutex
	lockComments                sync.RWMutex
	lockCreateComment           sync.RWMutex
	lockCreateTimelineItem      sync.RWMutex
	lockDeleteComment           sync.RWMutex
	lockDeletePost              sync.RWMutex
	lockDeleteTimelineItem      sync.RWMutex
	lockDevLogin                sync.RWMutex
	lockFollowees               sync.RWMutex
	lockFollowers               sync.RWMutex
	lockHasUnreadNotifications  sync.RWMutex
	lockLoginFromProvider       sync.RWMutex
	lockMarkNotificationAsRead  sync.RWMutex
	lockMarkNotificationsAsRead sync.RWMutex
	lockNotificationStream      sync.RWMutex
	lockNotifications           sync.RWMutex
	lockParseRedirectURI        sync.RWMutex
	lockPost                    sync.RWMutex
	lockPostStream              sync.RWMutex
	lockPosts                   sync.RWMutex
	lockSendMagicLink           sync.RWMutex
	lockTimeline                sync.RWMutex
	lockTimelineItemStream      sync.RWMutex
	lockToggleCommentReaction   sync.RWMutex
	lockToggleFollow            sync.RWMutex
	lockTogglePostReaction      sync.RWMutex
	lockTogglePostSubscription  sync.RWMutex
	lockToken                   sync.RWMutex
	lockUpdateAvatar            sync.RWMutex
	lockUpdateCover             sync.RWMutex
	lockUpdateUser              sync.RWMutex
	lockUser                    sync.RWMutex
	lockUsernames               sync.RWMutex
	lockUsers                   sync.RWMutex
	lockVerifyMagicLink         sync.RWMutex
}

// AddWebPushSubscription calls AddWebPushSubscriptionFunc.
func (mock *ServiceMock) AddWebPushSubscription(ctx context.Context, sub webpush.Subscription) error {
	callInfo := struct {
		Ctx context.Context
		Sub webpush.Subscription
	}{
		Ctx: ctx,
		Sub: sub,
	}
	mock.lockAddWebPushSubscription.Lock()
	mock.calls.AddWebPushSubscription = append(mock.calls.AddWebPushSubscription, callInfo)
	mock.lockAddWebPushSubscription.Unlock()
	if mock.AddWebPushSubscriptionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AddWebPushSubscriptionFunc(ctx, sub)
}

// AddWebPushSubscriptionCalls gets all the calls that were made to AddWebPushSubscription.
// Check the length with:
//
//	len(mockedService.AddWebPushSubscriptionCalls())
func (mock *ServiceMock) AddWebPushSubscriptionCalls() []struct {
	Ctx context.Context
	Sub webpush.Subscription
} {
	var calls []struct {
		Ctx context.Context
		Sub webpush.Subscription
	}
	mock.lockAddWebPushSubscription.RLock()
	calls = mock.calls.AddWebPushSubscription
	mock.lockAddWebPushSubscription.RUnlock()
	return calls
}

// AuthUser calls AuthUserFunc.
func (mock *ServiceMock) AuthUser(ctx context.Context) (nakama.User, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthUser.Lock()
	mock.calls.AuthUser = append(mock.calls.AuthUser, callInfo)
	mock.lockAuthUser.Unlock()
	if mock.AuthUserFunc == nil {
		var (
			userOut nakama.User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.AuthUserFunc(ctx)
}

// AuthUserCalls gets all the calls that were made to AuthUser.
// Check the length with:
//
//	len(mockedService.AuthUserCalls())
func (mock *ServiceMock) AuthUserCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthUser.RLock()
	calls = mock.calls.AuthUser
	mock.lockAuthUser.RUnlock()
	return calls
}

// AuthUserIDFromToken calls AuthUserIDFromTokenFunc.
func (mock *ServiceMock) AuthUserIDFromToken(token string) (string, error) {
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	mock.lockAuthUserIDFromToken.Lock()
	mock.calls.AuthUserIDFromToken = append(mock.calls.AuthUserIDFromToken, callInfo)
	mock.lockAuthUserIDFromToken.Unlock()
	if mock.AuthUserIDFromTokenFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.AuthUserIDFromTokenFunc(token)
}

// AuthUserIDFromTokenCalls gets all the calls that were made to AuthUserIDFromToken.
// Check the length with:
//
//	len(mockedService.AuthUserIDFromTokenCalls())
func (mock *ServiceMock) AuthUserIDFromTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	mock.lockAuthUserIDFromToken.RLock()
	calls = mock.calls.AuthUserIDFromToken
	mock.lockAuthUserIDFromToken.RUnlock()
	return calls
}

// CommentStream calls CommentStreamFunc.
func (mock *ServiceMock) CommentStream(ctx context.Context, postID string) (<-chan nakama.Comment, error) {
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockCommentStream.Lock()
	mock.calls.CommentStream = append(mock.calls.CommentStream, callInfo)
	mock.lockCommentStream.Unlock()
	if mock.CommentStreamFunc == nil {
		var (
			commentChOut <-chan nakama.Comment
			errOut       error
		)
		return commentChOut, errOut
	}
	return mock.CommentStreamFunc(ctx, postID)
}

// CommentStreamCalls gets all the calls that were made to CommentStream.
// Check the length with:
//
//	len(mockedService.CommentStreamCalls())
func (mock *ServiceMock) CommentStreamCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockCommentStream.RLock()
	calls = mock.calls.CommentStream
	mock.lockCommentStream.RUnlock()
	return calls
}

// Comments calls CommentsFunc.
func (mock *ServiceMock) Comments(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error) {
	callInfo := struct {
		Ctx    context.Context
		PostID string
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		PostID: postID,
		Last:   last,
		Before: before,
	}
	mock.lockComments.Lock()
	mock.calls.Comments = append(mock.calls.Comments, callInfo)
	mock.lockComments.Unlock()
	if mock.CommentsFunc == nil {
		var (
			commentsOut nakama.Comments
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.CommentsFunc(ctx, postID, last, before)
}

// CommentsCalls gets all the calls that were made to Comments.
// Check the length with:
//
//	len(mockedService.CommentsCalls())
func (mock *ServiceMock) CommentsCalls() []struct {
	Ctx    context.Context
	PostID string
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
		Last   uint64
		Before *string
	}
	mock.lockComments.RLock()
	calls = mock.calls.Comments
	mock.lockComments.RUnlock()
	return calls
}

// CreateComment calls CreateCommentFunc.
func (mock *ServiceMock) CreateComment(ctx context.Context, postID string, content string) (nakama.Comment, error) {
	callInfo := struct {
		Ctx     context.Context
		PostID  string
		Content string
	}{
		Ctx:     ctx,
		PostID:  postID,
		Content: content,
	}
	mock.lockCreateComment.Lock()
	mock.calls.CreateComment = append(mock.calls.CreateComment, callInfo)
	mock.lockCreateComment.Unlock()
	if mock.CreateCommentFunc == nil {
		var (
			commentOut nakama.Comment
			errOut     error
		)
		return commentOut, errOut
	}
	return mock.CreateCommentFunc(ctx, postID, content)
}

// CreateCommentCalls gets all the calls that were made to CreateComment.
// Check the length with:
//
//	len(mockedService.CreateCommentCalls())
func (mock *ServiceMock) CreateCommentCalls() []struct {
	Ctx     context.Context
	PostID  string
	Content string
} {
	var calls []struct {
		Ctx     context.Context
		PostID  string
		Content string
	}
	mock.lockCreateComment.RLock()
	calls = mock.calls.CreateComment
	mock.lockCreateComment.RUnlock()
	return calls
}

// CreateTimelineItem calls CreateTimelineItemFunc.
func (mock *ServiceMock) CreateTimelineItem(ctx context.Context, content string, spoilerOf *string, nsfw bool, media []io.ReadSeeker) (nakama.TimelineItem, error) {
	callInfo := struct {
		Ctx       context.Context
		Content   string
		SpoilerOf *string
		Nsfw      bool
		Media     []io.ReadSeeker
	}{
		Ctx:       ctx,
		Content:   content,
		SpoilerOf: spoilerOf,
		Nsfw:      nsfw,
		Media:     media,
	}
	mock.lockCreateTimelineItem.Lock()
	mock.calls.CreateTimelineItem = append(mock.calls.CreateTimelineItem, callInfo)
	mock.lockCreateTimelineItem.Unlock()
	if mock.CreateTimelineItemFunc == nil {
		var (
			timelineItemOut nakama.TimelineItem
			errOut          error
		)
		return timelineItemOut, errOut
	}
	return mock.CreateTimelineItemFunc(ctx, content, spoilerOf, nsfw, media)
}

// CreateTimelineItemCalls gets all the calls that were made to CreateTimelineItem.
// Check the length with:
//
//	len(mockedService.CreateTimelineItemCalls())
func (mock *ServiceMock) CreateTimelineItemCalls() []struct {
	Ctx       context.Context
	Content   string
	SpoilerOf *string
	Nsfw      bool
	Media     []io.ReadSeeker
} {
	var calls []struct {
		Ctx       context.Context
		Content   string
		SpoilerOf *string
		Nsfw      bool
		Media     []io.ReadSeeker
	}
	mock.lockCreateTimelineItem.RLock()
	calls = mock.calls.CreateTimelineItem
	mock.lockCreateTimelineItem.RUnlock()
	return calls
}

// DeleteComment calls DeleteCommentFunc.
func (mock *ServiceMock) DeleteComment(ctx context.Context, commentID string) error {
	callInfo := struct {
		Ctx       context.Context
		CommentID string
	}{
		Ctx:       ctx,
		CommentID: commentID,
	}
	mock.lockDeleteComment.Lock()
	mock.calls.DeleteComment = append(mock.calls.DeleteComment, callInfo)
	mock.lockDeleteComment.Unlock()
	if mock.DeleteCommentFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteCommentFunc(ctx, commentID)
}

// DeleteCommentCalls gets all the calls that were made to DeleteComment.
// Check the length with:
//
//	len(mockedService.DeleteCommentCalls())
func (mock *ServiceMock) DeleteCommentCalls() []struct {
	Ctx       context.Context
	CommentID string
} {
	var calls []struct {
		Ctx       context.Context
		CommentID string
	}
	mock.lockDeleteComment.RLock()
	calls = mock.calls.DeleteComment
	mock.lockDeleteComment.RUnlock()
	return calls
}

// DeletePost calls DeletePostFunc.
func (mock *ServiceMock) DeletePost(ctx context.Context, postID string) error {
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockDeletePost.Lock()
	mock.calls.DeletePost = append(mock.calls.DeletePost, callInfo)
	mock.lockDeletePost.Unlock()
	if mock.DeletePostFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeletePostFunc(ctx, postID)
}

// DeletePostCalls gets all the calls that were made to DeletePost.
// Check the length with:
//
//	len(mockedService.DeletePostCalls())
func (mock *ServiceMock) DeletePostCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockDeletePost.RLock()
	calls = mock.calls.DeletePost
	mock.lockDeletePost.RUnlock()
	return calls
}

// DeleteTimelineItem calls DeleteTimelineItemFunc.
func (mock *ServiceMock) DeleteTimelineItem(ctx context.Context, timelineItemID string) error {
	callInfo := struct {
		Ctx            context.Context
		TimelineItemID string
	}{
		Ctx:            ctx,
		TimelineItemID: timelineItemID,
	}
	mock.lockDeleteTimelineItem.Lock()
	mock.calls.DeleteTimelineItem = append(mock.calls.DeleteTimelineItem, callInfo)
	mock.lockDeleteTimelineItem.Unlock()
	if mock.DeleteTimelineItemFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteTimelineItemFunc(ctx, timelineItemID)
}

// DeleteTimelineItemCalls gets all the calls that were made to DeleteTimelineItem.
// Check the length with:
//
//	len(mockedService.DeleteTimelineItemCalls())
func (mock *ServiceMock) DeleteTimelineItemCalls() []struct {
	Ctx            context.Context
	TimelineItemID string
} {
	var calls []struct {
		Ctx            context.Context
		TimelineItemID string
	}
	mock.lockDeleteTimelineItem.RLock()
	calls = mock.calls.DeleteTimelineItem
	mock.lockDeleteTimelineItem.RUnlock()
	return calls
}

// DevLogin calls DevLoginFunc.
func (mock *ServiceMock) DevLogin(ctx context.Context, email string) (nakama.AuthOutput, error) {
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockDevLogin.Lock()
	mock.calls.DevLogin = append(mock.calls.DevLogin, callInfo)
	mock.lockDevLogin.Unlock()
	if mock.DevLoginFunc == nil {
		var (
			authOutputOut nakama.AuthOutput
			errOut        error
		)
		return authOutputOut, errOut
	}
	return mock.DevLoginFunc(ctx, email)
}

// DevLoginCalls gets all the calls that were made to DevLogin.
// Check the length with:
//
//	len(mockedService.DevLoginCalls())
func (mock *ServiceMock) DevLoginCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockDevLogin.RLock()
	calls = mock.calls.DevLogin
	mock.lockDevLogin.RUnlock()
	return calls
}

// Followees calls FolloweesFunc.
func (mock *ServiceMock) Followees(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
	callInfo := struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}{
		Ctx:      ctx,
		Username: username,
		First:    first,
		After:    after,
	}
	mock.lockFollowees.Lock()
	mock.calls.Followees = append(mock.calls.Followees, callInfo)
	mock.lockFollowees.Unlock()
	if mock.FolloweesFunc == nil {
		var (
			userProfilesOut nakama.UserProfiles
			errOut          error
		)
		return userProfilesOut, errOut
	}
	return mock.FolloweesFunc(ctx, username, first, after)
}

// FolloweesCalls gets all the calls that were made to Followees.
// Check the length with:
//
//	len(mockedService.FolloweesCalls())
func (mock *ServiceMock) FolloweesCalls() []struct {
	Ctx      context.Context
	Username string
	First    uint64
	After    *string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}
	mock.lockFollowees.RLock()
	calls = mock.calls.Followees
	mock.lockFollowees.RUnlock()
	return calls
}

// Followers calls FollowersFunc.
func (mock *ServiceMock) Followers(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
	callInfo := struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}{
		Ctx:      ctx,
		Username: username,
		First:    first,
		After:    after,
	}
	mock.lockFollowers.Lock()
	mock.calls.Followers = append(mock.calls.Followers, callInfo)
	mock.lockFollowers.Unlock()
	if mock.FollowersFunc == nil {
		var (
			userProfilesOut nakama.UserProfiles
			errOut          error
		)
		return userProfilesOut, errOut
	}
	return mock.FollowersFunc(ctx, username, first, after)
}

// FollowersCalls gets all the calls that were made to Followers.
// Check the length with:
//
//	len(mockedService.FollowersCalls())
func (mock *ServiceMock) FollowersCalls() []struct {
	Ctx      context.Context
	Username string
	First    uint64
	After    *string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}
	mock.lockFollowers.RLock()
	calls = mock.calls.Followers
	mock.lockFollowers.RUnlock()
	return calls
}

// HasUnreadNotifications calls HasUnreadNotificationsFunc.
func (mock *ServiceMock) HasUnreadNotifications(ctx context.Context) (bool, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHasUnreadNotifications.Lock()
	mock.calls.HasUnreadNotifications = append(mock.calls.HasUnreadNotifications, callInfo)
	mock.lockHasUnreadNotifications.Unlock()
	if mock.HasUnreadNotificationsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.HasUnreadNotificationsFunc(ctx)
}

// HasUnreadNotificationsCalls gets all the calls that were made to HasUnreadNotifications.
// Check the length with:
//
//	len(mockedService.HasUnreadNotificationsCalls())
func (mock *ServiceMock) HasUnreadNotificationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHasUnreadNotifications.RLock()
	calls = mock.calls.HasUnreadNotifications
	mock.lockHasUnreadNotifications.RUnlock()
	return calls
}

// LoginFromProvider calls LoginFromProviderFunc.
func (mock *ServiceMock) LoginFromProvider(ctx context.Context, name string, user nakama.ProvidedUser) (nakama.User, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
		User nakama.ProvidedUser
	}{
		Ctx:  ctx,
		Name: name,
		User: user,
	}
	mock.lockLoginFromProvider.Lock()
	mock.calls.LoginFromProvider = append(mock.calls.LoginFromProvider, callInfo)
	mock.lockLoginFromProvider.Unlock()
	if mock.LoginFromProviderFunc == nil {
		var (
			userOut nakama.User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.LoginFromProviderFunc(ctx, name, user)
}

// LoginFromProviderCalls gets all the calls that were made to LoginFromProvider.
// Check the length with:
//
//	len(mockedService.LoginFromProviderCalls())
func (mock *ServiceMock) LoginFromProviderCalls() []struct {
	Ctx  context.Context
	Name string
	User nakama.ProvidedUser
} {
	var calls []struct {
		Ctx  context.Context
		Name string
		User nakama.ProvidedUser
	}
	mock.lockLoginFromProvider.RLock()
	calls = mock.calls.LoginFromProvider
	mock.lockLoginFromProvider.RUnlock()
	return calls
}

// MarkNotificationAsRead calls MarkNotificationAsReadFunc.
func (mock *ServiceMock) MarkNotificationAsRead(ctx context.Context, notificationID string) error {
	callInfo := struct {
		Ctx            context.Context
		NotificationID string
	}{
		Ctx:            ctx,
		NotificationID: notificationID,
	}
	mock.lockMarkNotificationAsRead.Lock()
	mock.calls.MarkNotificationAsRead = append(mock.calls.MarkNotificationAsRead, callInfo)
	mock.lockMarkNotificationAsRead.Unlock()
	if mock.MarkNotificationAsReadFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.MarkNotificationAsReadFunc(ctx, notificationID)
}

// MarkNotificationAsReadCalls gets all the calls that were made to MarkNotificationAsRead.
// Check the length with:
//
//	len(mockedService.MarkNotificationAsReadCalls())
func (mock *ServiceMock) MarkNotificationAsReadCalls() []struct {
	Ctx            context.Context
	NotificationID string
} {
	var calls []struct {
		Ctx            context.Context
		NotificationID string
	}
	mock.lockMarkNotificationAsRead.RLock()
	calls = mock.calls.MarkNotificationAsRead
	mock.lockMarkNotificationAsRead.RUnlock()
	return calls
}

// MarkNotificationsAsRead calls MarkNotificationsAsReadFunc.
func (mock *ServiceMock) MarkNotificationsAsRead(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMarkNotificationsAsRead.Lock()
	mock.calls.MarkNotificationsAsRead = append(mock.calls.MarkNotificationsAsRead, callInfo)
	mock.lockMarkNotificationsAsRead.Unlock()
	if mock.MarkNotificationsAsReadFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.MarkNotificationsAsReadFunc(ctx)
}

// MarkNotificationsAsReadCalls gets all the calls that were made to MarkNotificationsAsRead.
// Check the length with:
//
//	len(mockedService.MarkNotificationsAsReadCalls())
func (mock *ServiceMock) MarkNotificationsAsReadCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMarkNotificationsAsRead.RLock()
	calls = mock.calls.MarkNotificationsAsRead
	mock.lockMarkNotificationsAsRead.RUnlock()
	return calls
}

// NotificationStream calls NotificationStreamFunc.
func (mock *ServiceMock) NotificationStream(ctx context.Context) (<-chan nakama.Notification, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNotificationStream.Lock()
	mock.calls.NotificationStream = append(mock.calls.NotificationStream, callInfo)
	mock.lockNotificationStream.Unlock()
	if mock.NotificationStreamFunc == nil {
		var (
			notificationChOut <-chan nakama.Notification
			errOut            error
		)
		return notificationChOut, errOut
	}
	return mock.NotificationStreamFunc(ctx)
}

// NotificationStreamCalls gets all the calls that were made to NotificationStream.
// Check the length with:
//
//	len(mockedService.NotificationStreamCalls())
func (mock *ServiceMock) NotificationStreamCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNotificationStream.RLock()
	calls = mock.calls.NotificationStream
	mock.lockNotificationStream.RUnlock()
	return calls
}

// Notifications calls NotificationsFunc.
func (mock *ServiceMock) Notifications(ctx context.Context, last uint64, before *string) (nakama.Notifications, error) {
	callInfo := struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		Last:   last,
		Before: before,
	}
	mock.lockNotifications.Lock()
	mock.calls.Notifications = append(mock.calls.Notifications, callInfo)
	mock.lockNotifications.Unlock()
	if mock.NotificationsFunc == nil {
		var (
			notificationsOut nakama.Notifications
			errOut           error
		)
		return notificationsOut, errOut
	}
	return mock.NotificationsFunc(ctx, last, before)
}

// NotificationsCalls gets all the calls that were made to Notifications.
// Check the length with:
//
//	len(mockedService.NotificationsCalls())
func (mock *ServiceMock) NotificationsCalls() []struct {
	Ctx    context.Context
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}
	mock.lockNotifications.RLock()
	calls = mock.calls.Notifications
	mock.lockNotifications.RUnlock()
	return calls
}

// ParseRedirectURI calls ParseRedirectURIFunc.
func (mock *ServiceMock) ParseRedirectURI(rawurl string) (*url.URL, error) {
	callInfo := struct {
		Rawurl string
	}{
		Rawurl: rawurl,
	}
	mock.lockParseRedirectURI.Lock()
	mock.calls.ParseRedirectURI = append(mock.calls.ParseRedirectURI, callInfo)
	mock.lockParseRedirectURI.Unlock()
	if mock.ParseRedirectURIFunc == nil {
		var (
			uRLOut *url.URL
			errOut error
		)
		return uRLOut, errOut
	}
	return mock.ParseRedirectURIFunc(rawurl)
}

// ParseRedirectURICalls gets all the calls that were made to ParseRedirectURI.
// Check the length with:
//
//	len(mockedService.ParseRedirectURICalls())
func (mock *ServiceMock) ParseRedirectURICalls() []struct {
	Rawurl string
} {
	var calls []struct {
		Rawurl string
	}
	mock.lockParseRedirectURI.RLock()
	calls = mock.calls.ParseRedirectURI
	mock.lockParseRedirectURI.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *ServiceMock) Post(ctx context.Context, postID string) (nakama.Post, error) {
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	mock.lockPost.Unlock()
	if mock.PostFunc == nil {
		var (
			postOut nakama.Post
			errOut  error
		)
		return postOut, errOut
	}
	return mock.PostFunc(ctx, postID)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//
//	len(mockedService.PostCalls())
func (mock *ServiceMock) PostCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockPost.RLock()
	calls = mock.calls.Post
	mock.lockPost.RUnlock()
	return calls
}

// PostStream calls PostStreamFunc.
func (mock *ServiceMock) PostStream(ctx context.Context) (<-chan nakama.Post, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPostStream.Lock()
	mock.calls.PostStream = append(mock.calls.PostStream, callInfo)
	mock.lockPostStream.Unlock()
	if mock.PostStreamFunc == nil {
		var (
			postChOut <-chan nakama.Post
			errOut    error
		)
		return postChOut, errOut
	}
	return mock.PostStreamFunc(ctx)
}

// PostStreamCalls gets all the calls that were made to PostStream.
// Check the length with:
//
//	len(mockedService.PostStreamCalls())
func (mock *ServiceMock) PostStreamCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPostStream.RLock()
	calls = mock.calls.PostStream
	mock.lockPostStream.RUnlock()
	return calls
}

// Posts calls PostsFunc.
func (mock *ServiceMock) Posts(ctx context.Context, last uint64, before *string, opts ...nakama.PostsOpt) (nakama.Posts, error) {
	callInfo := struct {
		Ctx    context.Context
		Last   uint64
		Before *string
		Opts   []nakama.PostsOpt
	}{
		Ctx:    ctx,
		Last:   last,
		Before: before,
		Opts:   opts,
	}
	mock.lockPosts.Lock()
	mock.calls.Posts = append(mock.calls.Posts, callInfo)
	mock.lockPosts.Unlock()
	if mock.PostsFunc == nil {
		var (
			postsOut nakama.Posts
			errOut   error
		)
		return postsOut, errOut
	}
	return mock.PostsFunc(ctx, last, before, opts...)
}

// PostsCalls gets all the calls that were made to Posts.
// Check the length with:
//
//	len(mockedService.PostsCalls())
func (mock *ServiceMock) PostsCalls() []struct {
	Ctx    context.Context
	Last   uint64
	Before *string
	Opts   []nakama.PostsOpt
} {
	var calls []struct {
		Ctx    context.Context
		Last   uint64
		Before *string
		Opts   []nakama.PostsOpt
	}
	mock.lockPosts.RLock()
	calls = mock.calls.Posts
	mock.lockPosts.RUnlock()
	return calls
}

// SendMagicLink calls SendMagicLinkFunc.
func (mock *ServiceMock) SendMagicLink(ctx context.Context, in nakama.SendMagicLink) error {
	callInfo := struct {
		Ctx context.Context
		In  nakama.SendMagicLink
	}{
		Ctx: ctx,
		In:  in,
	}
	mock.lockSendMagicLink.Lock()
	mock.calls.SendMagicLink = append(mock.calls.SendMagicLink, callInfo)
	mock.lockSendMagicLink.Unlock()
	if mock.SendMagicLinkFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SendMagicLinkFunc(ctx, in)
}

// SendMagicLinkCalls gets all the calls that were made to SendMagicLink.
// Check the length with:
//
//	len(mockedService.SendMagicLinkCalls())
func (mock *ServiceMock) SendMagicLinkCalls() []struct {
	Ctx context.Context
	In  nakama.SendMagicLink
} {
	var calls []struct {
		Ctx context.Context
		In  nakama.SendMagicLink
	}
	mock.lockSendMagicLink.RLock()
	calls = mock.calls.SendMagicLink
	mock.lockSendMagicLink.RUnlock()
	return calls
}

// Timeline calls TimelineFunc.
func (mock *ServiceMock) Timeline(ctx context.Context, last uint64, before *string) (nakama.Timeline, error) {
	callInfo := struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		Last:   last,
		Before: before,
	}
	mock.lockTimeline.Lock()
	mock.calls.Timeline = append(mock.calls.Timeline, callInfo)
	mock.lockTimeline.Unlock()
	if mock.TimelineFunc == nil {
		var (
			timelineOut nakama.Timeline
			errOut      error
		)
		return timelineOut, errOut
	}
	return mock.TimelineFunc(ctx, last, before)
}

// TimelineCalls gets all the calls that were made to Timeline.
// Check the length with:
//
//	len(mockedService.TimelineCalls())
func (mock *ServiceMock) TimelineCalls() []struct {
	Ctx    context.Context
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}
	mock.lockTimeline.RLock()
	calls = mock.calls.Timeline
	mock.lockTimeline.RUnlock()
	return calls
}

// TimelineItemStream calls TimelineItemStreamFunc.
func (mock *ServiceMock) TimelineItemStream(ctx context.Context) (<-chan nakama.TimelineItem, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockTimelineItemStream.Lock()
	mock.calls.TimelineItemStream = append(mock.calls.TimelineItemStream, callInfo)
	mock.lockTimelineItemStream.Unlock()
	if mock.TimelineItemStreamFunc == nil {
		var (
			timelineItemChOut <-chan nakama.TimelineItem
			errOut            error
		)
		return timelineItemChOut, errOut
	}
	return mock.TimelineItemStreamFunc(ctx)
}

// TimelineItemStreamCalls gets all the calls that were made to TimelineItemStream.
// Check the length with:
//
//	len(mockedService.TimelineItemStreamCalls())
func (mock *ServiceMock) TimelineItemStreamCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockTimelineItemStream.RLock()
	calls = mock.calls.TimelineItemStream
	mock.lockTimelineItemStream.RUnlock()
	return calls
}

// ToggleCommentReaction calls ToggleCommentReactionFunc.
func (mock *ServiceMock) ToggleCommentReaction(ctx context.Context, commentID string, in nakama.ReactionInput) ([]nakama.Reaction, error) {
	callInfo := struct {
		Ctx       context.Context
		CommentID string
		In        nakama.ReactionInput
	}{
		Ctx:       ctx,
		CommentID: commentID,
		In:        in,
	}
	mock.lockToggleCommentReaction.Lock()
	mock.calls.ToggleCommentReaction = append(mock.calls.ToggleCommentReaction, callInfo)
	mock.lockToggleCommentReaction.Unlock()
	if mock.ToggleCommentReactionFunc == nil {
		var (
			reactionsOut []nakama.Reaction
			errOut       error
		)
		return reactionsOut, errOut
	}
	return mock.ToggleCommentReactionFunc(ctx, commentID, in)
}

// ToggleCommentReactionCalls gets all the calls that were made to ToggleCommentReaction.
// Check the length with:
//
//	len(mockedService.ToggleCommentReactionCalls())
func (mock *ServiceMock) ToggleCommentReactionCalls() []struct {
	Ctx       context.Context
	CommentID string
	In        nakama.ReactionInput
} {
	var calls []struct {
		Ctx       context.Context
		CommentID string
		In        nakama.ReactionInput
	}
	mock.lockToggleCommentReaction.RLock()
	calls = mock.calls.ToggleCommentReaction
	mock.lockToggleCommentReaction.RUnlock()
	return calls
}

// ToggleFollow calls ToggleFollowFunc.
func (mock *ServiceMock) ToggleFollow(ctx context.Context, username string) (nakama.ToggleFollowOutput, error) {
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockToggleFollow.Lock()
	mock.calls.ToggleFollow = append(mock.calls.ToggleFollow, callInfo)
	mock.lockToggleFollow.Unlock()
	if mock.ToggleFollowFunc == nil {
		var (
			toggleFollowOutputOut nakama.ToggleFollowOutput
			errOut                error
		)
		return toggleFollowOutputOut, errOut
	}
	return mock.ToggleFollowFunc(ctx, username)
}

// ToggleFollowCalls gets all the calls that were made to ToggleFollow.
// Check the length with:
//
//	len(mockedService.ToggleFollowCalls())
func (mock *ServiceMock) ToggleFollowCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockToggleFollow.RLock()
	calls = mock.calls.ToggleFollow
	mock.lockToggleFollow.RUnlock()
	return calls
}

// TogglePostReaction calls TogglePostReactionFunc.
func (mock *ServiceMock) TogglePostReaction(ctx context.Context, postID string, in nakama.ReactionInput) ([]nakama.Reaction, error) {
	callInfo := struct {
		Ctx    context.Context
		PostID string
		In     nakama.ReactionInput
	}{
		Ctx:    ctx,
		PostID: postID,
		In:     in,
	}
	mock.lockTogglePostReaction.Lock()
	mock.calls.TogglePostReaction = append(mock.calls.TogglePostReaction, callInfo)
	mock.lockTogglePostReaction.Unlock()
	if mock.TogglePostReactionFunc == nil {
		var (
			reactionsOut []nakama.Reaction
			errOut       error
		)
		return reactionsOut, errOut
	}
	return mock.TogglePostReactionFunc(ctx, postID, in)
}

// TogglePostReactionCalls gets all the calls that were made to TogglePostReaction.
// Check the length with:
//
//	len(mockedService.TogglePostReactionCalls())
func (mock *ServiceMock) TogglePostReactionCalls() []struct {
	Ctx    context.Context
	PostID string
	In     nakama.ReactionInput
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
		In     nakama.ReactionInput
	}
	mock.lockTogglePostReaction.RLock()
	calls = mock.calls.TogglePostReaction
	mock.lockTogglePostReaction.RUnlock()
	return calls
}

// TogglePostSubscription calls TogglePostSubscriptionFunc.
func (mock *ServiceMock) TogglePostSubscription(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error) {
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockTogglePostSubscription.Lock()
	mock.calls.TogglePostSubscription = append(mock.calls.TogglePostSubscription, callInfo)
	mock.lockTogglePostSubscription.Unlock()
	if mock.TogglePostSubscriptionFunc == nil {
		var (
			toggleSubscriptionOutputOut nakama.ToggleSubscriptionOutput
			errOut                      error
		)
		return toggleSubscriptionOutputOut, errOut
	}
	return mock.TogglePostSubscriptionFunc(ctx, postID)
}

// TogglePostSubscriptionCalls gets all the calls that were made to TogglePostSubscription.
// Check the length with:
//
//	len(mockedService.TogglePostSubscriptionCalls())
func (mock *ServiceMock) TogglePostSubscriptionCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockTogglePostSubscription.RLock()
	calls = mock.calls.TogglePostSubscription
	mock.lockTogglePostSubscription.RUnlock()
	return calls
}

// Token calls TokenFunc.
func (mock *ServiceMock) Token(ctx context.Context) (nakama.TokenOutput, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockToken.Lock()
	mock.calls.Token = append(mock.calls.Token, callInfo)
	mock.lockToken.Unlock()
	if mock.TokenFunc == nil {
		var (
			tokenOutputOut nakama.TokenOutput
			errOut         error
		)
		return tokenOutputOut, errOut
	}
	return mock.TokenFunc(ctx)
}

// TokenCalls gets all the calls that were made to Token.
// Check the length with:
//
//	len(mockedService.TokenCalls())
func (mock *ServiceMock) TokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockToken.RLock()
	calls = mock.calls.Token
	mock.lockToken.RUnlock()
	return calls
}

// UpdateAvatar calls UpdateAvatarFunc.
func (mock *ServiceMock) UpdateAvatar(ctx context.Context, r io.ReadSeeker) (string, error) {
	callInfo := struct {
		Ctx context.Context
		R   io.ReadSeeker
	}{
		Ctx: ctx,
		R:   r,
	}
	mock.lockUpdateAvatar.Lock()
	mock.calls.UpdateAvatar = append(mock.calls.UpdateAvatar, callInfo)
	mock.lockUpdateAvatar.Unlock()
	if mock.UpdateAvatarFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.UpdateAvatarFunc(ctx, r)
}

// UpdateAvatarCalls gets all the calls that were made to UpdateAvatar.
// Check the length with:
//
//	len(mockedService.UpdateAvatarCalls())
func (mock *ServiceMock) UpdateAvatarCalls() []struct {
	Ctx context.Context
	R   io.ReadSeeker
} {
	var calls []struct {
		Ctx context.Context
		R   io.ReadSeeker
	}
	mock.lockUpdateAvatar.RLock()
	calls = mock.calls.UpdateAvatar
	mock.lockUpdateAvatar.RUnlock()
	return calls
}

// UpdateCover calls UpdateCoverFunc.
func (mock *ServiceMock) UpdateCover(ctx context.Context, r io.ReadSeeker) (string, error) {
	callInfo := struct {
		Ctx context.Context
		R   io.ReadSeeker
	}{
		Ctx: ctx,
		R:   r,
	}
	mock.lockUpdateCover.Lock()
	mock.calls.UpdateCover = append(mock.calls.UpdateCover, callInfo)
	mock.lockUpdateCover.Unlock()
	if mock.UpdateCoverFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.UpdateCoverFunc(ctx, r)
}

// UpdateCoverCalls gets all the calls that were made to UpdateCover.
// Check the length with:
//
//	len(mockedService.UpdateCoverCalls())
func (mock *ServiceMock) UpdateCoverCalls() []struct {
	Ctx context.Context
	R   io.ReadSeeker
} {
	var calls []struct {
		Ctx context.Context
		R   io.ReadSeeker
	}
	mock.lockUpdateCover.RLock()
	calls = mock.calls.UpdateCover
	mock.lockUpdateCover.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *ServiceMock) UpdateUser(ctx context.Context, params nakama.UpdateUserParams) error {
	callInfo := struct {
		Ctx    context.Context
		Params nakama.UpdateUserParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	if mock.UpdateUserFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateUserFunc(ctx, params)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockedService.UpdateUserCalls())
func (mock *ServiceMock) UpdateUserCalls() []struct {
	Ctx    context.Context
	Params nakama.UpdateUserParams
} {
	var calls []struct {
		Ctx    context.Context
		Params nakama.UpdateUserParams
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *ServiceMock) User(ctx context.Context, username string) (nakama.UserProfile, error) {
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	if mock.UserFunc == nil {
		var (
			userProfileOut nakama.UserProfile
			errOut         error
		)
		return userProfileOut, errOut
	}
	return mock.UserFunc(ctx, username)
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedService.UserCalls())
func (mock *ServiceMock) UserCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Usernames calls UsernamesFunc.
func (mock *ServiceMock) Usernames(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error) {
	callInfo := struct {
		Ctx          context.Context
		StartingWith string
		First        uint64
		After        *string
	}{
		Ctx:          ctx,
		StartingWith: startingWith,
		First:        first,
		After:        after,
	}
	mock.lockUsernames.Lock()
	mock.calls.Usernames = append(mock.calls.Usernames, callInfo)
	mock.lockUsernames.Unlock()
	if mock.UsernamesFunc == nil {
		var (
			usernamesOut nakama.Usernames
			errOut       error
		)
		return usernamesOut, errOut
	}
	return mock.UsernamesFunc(ctx, startingWith, first, after)
}

// UsernamesCalls gets all the calls that were made to Usernames.
// Check the length with:
//
//	len(mockedService.UsernamesCalls())
func (mock *ServiceMock) UsernamesCalls() []struct {
	Ctx          context.Context
	StartingWith string
	First        uint64
	After        *string
} {
	var calls []struct {
		Ctx          context.Context
		StartingWith string
		First        uint64
		After        *string
	}
	mock.lockUsernames.RLock()
	calls = mock.calls.Usernames
	mock.lockUsernames.RUnlock()
	return calls
}

// Users calls UsersFunc.
func (mock *ServiceMock) Users(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error) {
	callInfo := struct {
		Ctx    context.Context
		Search string
		First  uint64
		After  *string
	}{
		Ctx:    ctx,
		Search: search,
		First:  first,
		After:  after,
	}
	mock.lockUsers.Lock()
	mock.calls.Users = append(mock.calls.Users, callInfo)
	mock.lockUsers.Unlock()
	if mock.UsersFunc == nil {
		var (
			userProfilesOut nakama.UserProfiles
			errOut          error
		)
		return userProfilesOut, errOut
	}
	return mock.UsersFunc(ctx, search, first, after)
}

// UsersCalls gets all the calls that were made to Users.
// Check the length with:
//
//	len(mockedService.UsersCalls())
func (mock *ServiceMock) UsersCalls() []struct {
	Ctx    context.Context
	Search string
	First  uint64
	After  *string
} {
	var calls []struct {
		Ctx    context.Context
		Search string
		First  uint64
		After  *string
	}
	mock.lockUsers.RLock()
	calls = mock.calls.Users
	mock.lockUsers.RUnlock()
	return calls
}

// VerifyMagicLink calls VerifyMagicLinkFunc.
func (mock *ServiceMock) VerifyMagicLink(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error) {
	callInfo := struct {
		Ctx      context.Context
		Email    string
		Code     string
		Username *string
	}{
		Ctx:      ctx,
		Email:    email,
		Code:     code,
		Username: username,
	}
	mock.lockVerifyMagicLink.Lock()
	mock.calls.VerifyMagicLink = append(mock.calls.VerifyMagicLink, callInfo)
	mock.lockVerifyMagicLink.Unlock()
	if mock.VerifyMagicLinkFunc == nil {
		var (
			authOutputOut nakama.AuthOutput
			errOut        error
		)
		return authOutputOut, errOut
	}
	return mock.VerifyMagicLinkFunc(ctx, email, code, username)
}

// VerifyMagicLinkCalls gets all the calls that were made to VerifyMagicLink.
// Check the length with:
//
//	len(mockedService.VerifyMagicLinkCalls())
func (mock *ServiceMock) VerifyMagicLinkCalls() []struct {
	Ctx      context.Context
	Email    string
	Code     string
	Username *string
} {
	var calls []struct {
		Ctx      context.Context
		Email    string
		Code     string
		Username *string
	}
	mock.lockVerifyMagicLink.RLock()
	calls = mock.calls.VerifyMagicLink
	mock.lockVerifyMagicLink.RUnlock()
	return calls
}
