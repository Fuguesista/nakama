// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package transport

import (
	"context"
	"github.com/duo-labs/webauthn/protocol"
	"github.com/duo-labs/webauthn/webauthn"
	"github.com/nicolasparada/nakama"
	"io"
	"net/url"
	"sync"
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
// 	func TestSomethingThatUsesService(t *testing.T) {
//
// 		// make and configure a mocked Service
// 		mockedService := &ServiceMock{
// 			AuthUserFunc: func(ctx context.Context) (nakama.User, error) {
// 				panic("mock out the AuthUser method")
// 			},
// 			AuthUserIDFromTokenFunc: func(token string) (string, error) {
// 				panic("mock out the AuthUserIDFromToken method")
// 			},
// 			CommentStreamFunc: func(ctx context.Context, postID string) (<-chan nakama.Comment, error) {
// 				panic("mock out the CommentStream method")
// 			},
// 			CommentsFunc: func(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error) {
// 				panic("mock out the Comments method")
// 			},
// 			CreateCommentFunc: func(ctx context.Context, postID string, content string) (nakama.Comment, error) {
// 				panic("mock out the CreateComment method")
// 			},
// 			CreateTimelineItemFunc: func(ctx context.Context, content string, spoilerOf *string, nsfw bool) (nakama.TimelineItem, error) {
// 				panic("mock out the CreateTimelineItem method")
// 			},
// 			CredentialCreationOptionsFunc: func(ctx context.Context) (*protocol.CredentialCreation, *webauthn.SessionData, error) {
// 				panic("mock out the CredentialCreationOptions method")
// 			},
// 			CredentialRequestOptionsFunc: func(ctx context.Context, email string, opts ...nakama.CredentialRequestOptionsOpt) (*protocol.CredentialAssertion, *webauthn.SessionData, error) {
// 				panic("mock out the CredentialRequestOptions method")
// 			},
// 			DeletePostFunc: func(ctx context.Context, postID string) error {
// 				panic("mock out the DeletePost method")
// 			},
// 			DeleteTimelineItemFunc: func(ctx context.Context, timelineItemID string) error {
// 				panic("mock out the DeleteTimelineItem method")
// 			},
// 			DevLoginFunc: func(ctx context.Context, email string) (nakama.AuthOutput, error) {
// 				panic("mock out the DevLogin method")
// 			},
// 			FolloweesFunc: func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
// 				panic("mock out the Followees method")
// 			},
// 			FollowersFunc: func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
// 				panic("mock out the Followers method")
// 			},
// 			HasUnreadNotificationsFunc: func(ctx context.Context) (bool, error) {
// 				panic("mock out the HasUnreadNotifications method")
// 			},
// 			MarkNotificationAsReadFunc: func(ctx context.Context, notificationID string) error {
// 				panic("mock out the MarkNotificationAsRead method")
// 			},
// 			MarkNotificationsAsReadFunc: func(ctx context.Context) error {
// 				panic("mock out the MarkNotificationsAsRead method")
// 			},
// 			NotificationStreamFunc: func(ctx context.Context) (<-chan nakama.Notification, error) {
// 				panic("mock out the NotificationStream method")
// 			},
// 			NotificationsFunc: func(ctx context.Context, last uint64, before *string) (nakama.Notifications, error) {
// 				panic("mock out the Notifications method")
// 			},
// 			ParseRedirectURIFunc: func(rawurl string) (*url.URL, error) {
// 				panic("mock out the ParseRedirectURI method")
// 			},
// 			PostFunc: func(ctx context.Context, postID string) (nakama.Post, error) {
// 				panic("mock out the Post method")
// 			},
// 			PostsFunc: func(ctx context.Context, username string, last uint64, before *string) (nakama.Posts, error) {
// 				panic("mock out the Posts method")
// 			},
// 			RegisterCredentialFunc: func(ctx context.Context, data webauthn.SessionData, parsedReply *protocol.ParsedCredentialCreationData) error {
// 				panic("mock out the RegisterCredential method")
// 			},
// 			SendMagicLinkFunc: func(ctx context.Context, email string, redirectURI string) error {
// 				panic("mock out the SendMagicLink method")
// 			},
// 			TimelineFunc: func(ctx context.Context, last uint64, before *string) (nakama.Timeline, error) {
// 				panic("mock out the Timeline method")
// 			},
// 			TimelineItemStreamFunc: func(ctx context.Context) (<-chan nakama.TimelineItem, error) {
// 				panic("mock out the TimelineItemStream method")
// 			},
// 			ToggleCommentLikeFunc: func(ctx context.Context, commentID string) (nakama.ToggleLikeOutput, error) {
// 				panic("mock out the ToggleCommentLike method")
// 			},
// 			ToggleFollowFunc: func(ctx context.Context, username string) (nakama.ToggleFollowOutput, error) {
// 				panic("mock out the ToggleFollow method")
// 			},
// 			TogglePostLikeFunc: func(ctx context.Context, postID string) (nakama.ToggleLikeOutput, error) {
// 				panic("mock out the TogglePostLike method")
// 			},
// 			TogglePostSubscriptionFunc: func(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error) {
// 				panic("mock out the TogglePostSubscription method")
// 			},
// 			TokenFunc: func(ctx context.Context) (nakama.TokenOutput, error) {
// 				panic("mock out the Token method")
// 			},
// 			UpdateAvatarFunc: func(ctx context.Context, r io.Reader) (string, error) {
// 				panic("mock out the UpdateAvatar method")
// 			},
// 			UpdateUserFunc: func(ctx context.Context, params nakama.UpdateUserParams) (nakama.UpdatedUserFields, error) {
// 				panic("mock out the UpdateUser method")
// 			},
// 			UserFunc: func(ctx context.Context, username string) (nakama.UserProfile, error) {
// 				panic("mock out the User method")
// 			},
// 			UsernamesFunc: func(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error) {
// 				panic("mock out the Usernames method")
// 			},
// 			UsersFunc: func(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error) {
// 				panic("mock out the Users method")
// 			},
// 			VerifyMagicLinkFunc: func(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error) {
// 				panic("mock out the VerifyMagicLink method")
// 			},
// 			WebAuthnLoginFunc: func(ctx context.Context, data webauthn.SessionData, reply *protocol.ParsedCredentialAssertionData) (nakama.AuthOutput, error) {
// 				panic("mock out the WebAuthnLogin method")
// 			},
// 		}
//
// 		// use mockedService in code that requires Service
// 		// and then make assertions.
//
// 	}
type ServiceMock struct {
	// AuthUserFunc mocks the AuthUser method.
	AuthUserFunc func(ctx context.Context) (nakama.User, error)

	// AuthUserIDFromTokenFunc mocks the AuthUserIDFromToken method.
	AuthUserIDFromTokenFunc func(token string) (string, error)

	// CommentStreamFunc mocks the CommentStream method.
	CommentStreamFunc func(ctx context.Context, postID string) (<-chan nakama.Comment, error)

	// CommentsFunc mocks the Comments method.
	CommentsFunc func(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error)

	// CreateCommentFunc mocks the CreateComment method.
	CreateCommentFunc func(ctx context.Context, postID string, content string) (nakama.Comment, error)

	// CreateTimelineItemFunc mocks the CreateTimelineItem method.
	CreateTimelineItemFunc func(ctx context.Context, content string, spoilerOf *string, nsfw bool) (nakama.TimelineItem, error)

	// CredentialCreationOptionsFunc mocks the CredentialCreationOptions method.
	CredentialCreationOptionsFunc func(ctx context.Context) (*protocol.CredentialCreation, *webauthn.SessionData, error)

	// CredentialRequestOptionsFunc mocks the CredentialRequestOptions method.
	CredentialRequestOptionsFunc func(ctx context.Context, email string, opts ...nakama.CredentialRequestOptionsOpt) (*protocol.CredentialAssertion, *webauthn.SessionData, error)

	// DeletePostFunc mocks the DeletePost method.
	DeletePostFunc func(ctx context.Context, postID string) error

	// DeleteTimelineItemFunc mocks the DeleteTimelineItem method.
	DeleteTimelineItemFunc func(ctx context.Context, timelineItemID string) error

	// DevLoginFunc mocks the DevLogin method.
	DevLoginFunc func(ctx context.Context, email string) (nakama.AuthOutput, error)

	// FolloweesFunc mocks the Followees method.
	FolloweesFunc func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error)

	// FollowersFunc mocks the Followers method.
	FollowersFunc func(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error)

	// HasUnreadNotificationsFunc mocks the HasUnreadNotifications method.
	HasUnreadNotificationsFunc func(ctx context.Context) (bool, error)

	// MarkNotificationAsReadFunc mocks the MarkNotificationAsRead method.
	MarkNotificationAsReadFunc func(ctx context.Context, notificationID string) error

	// MarkNotificationsAsReadFunc mocks the MarkNotificationsAsRead method.
	MarkNotificationsAsReadFunc func(ctx context.Context) error

	// NotificationStreamFunc mocks the NotificationStream method.
	NotificationStreamFunc func(ctx context.Context) (<-chan nakama.Notification, error)

	// NotificationsFunc mocks the Notifications method.
	NotificationsFunc func(ctx context.Context, last uint64, before *string) (nakama.Notifications, error)

	// ParseRedirectURIFunc mocks the ParseRedirectURI method.
	ParseRedirectURIFunc func(rawurl string) (*url.URL, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, postID string) (nakama.Post, error)

	// PostsFunc mocks the Posts method.
	PostsFunc func(ctx context.Context, username string, last uint64, before *string) (nakama.Posts, error)

	// RegisterCredentialFunc mocks the RegisterCredential method.
	RegisterCredentialFunc func(ctx context.Context, data webauthn.SessionData, parsedReply *protocol.ParsedCredentialCreationData) error

	// SendMagicLinkFunc mocks the SendMagicLink method.
	SendMagicLinkFunc func(ctx context.Context, email string, redirectURI string) error

	// TimelineFunc mocks the Timeline method.
	TimelineFunc func(ctx context.Context, last uint64, before *string) (nakama.Timeline, error)

	// TimelineItemStreamFunc mocks the TimelineItemStream method.
	TimelineItemStreamFunc func(ctx context.Context) (<-chan nakama.TimelineItem, error)

	// ToggleCommentLikeFunc mocks the ToggleCommentLike method.
	ToggleCommentLikeFunc func(ctx context.Context, commentID string) (nakama.ToggleLikeOutput, error)

	// ToggleFollowFunc mocks the ToggleFollow method.
	ToggleFollowFunc func(ctx context.Context, username string) (nakama.ToggleFollowOutput, error)

	// TogglePostLikeFunc mocks the TogglePostLike method.
	TogglePostLikeFunc func(ctx context.Context, postID string) (nakama.ToggleLikeOutput, error)

	// TogglePostSubscriptionFunc mocks the TogglePostSubscription method.
	TogglePostSubscriptionFunc func(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error)

	// TokenFunc mocks the Token method.
	TokenFunc func(ctx context.Context) (nakama.TokenOutput, error)

	// UpdateAvatarFunc mocks the UpdateAvatar method.
	UpdateAvatarFunc func(ctx context.Context, r io.Reader) (string, error)

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, params nakama.UpdateUserParams) (nakama.UpdatedUserFields, error)

	// UserFunc mocks the User method.
	UserFunc func(ctx context.Context, username string) (nakama.UserProfile, error)

	// UsernamesFunc mocks the Usernames method.
	UsernamesFunc func(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error)

	// UsersFunc mocks the Users method.
	UsersFunc func(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error)

	// VerifyMagicLinkFunc mocks the VerifyMagicLink method.
	VerifyMagicLinkFunc func(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error)

	// WebAuthnLoginFunc mocks the WebAuthnLogin method.
	WebAuthnLoginFunc func(ctx context.Context, data webauthn.SessionData, reply *protocol.ParsedCredentialAssertionData) (nakama.AuthOutput, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthUser holds details about calls to the AuthUser method.
		AuthUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// AuthUserIDFromToken holds details about calls to the AuthUserIDFromToken method.
		AuthUserIDFromToken []struct {
			// Token is the token argument value.
			Token string
		}
		// CommentStream holds details about calls to the CommentStream method.
		CommentStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// Comments holds details about calls to the Comments method.
		Comments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// CreateComment holds details about calls to the CreateComment method.
		CreateComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
			// Content is the content argument value.
			Content string
		}
		// CreateTimelineItem holds details about calls to the CreateTimelineItem method.
		CreateTimelineItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Content is the content argument value.
			Content string
			// SpoilerOf is the spoilerOf argument value.
			SpoilerOf *string
			// Nsfw is the nsfw argument value.
			Nsfw bool
		}
		// CredentialCreationOptions holds details about calls to the CredentialCreationOptions method.
		CredentialCreationOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CredentialRequestOptions holds details about calls to the CredentialRequestOptions method.
		CredentialRequestOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Opts is the opts argument value.
			Opts []nakama.CredentialRequestOptionsOpt
		}
		// DeletePost holds details about calls to the DeletePost method.
		DeletePost []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// DeleteTimelineItem holds details about calls to the DeleteTimelineItem method.
		DeleteTimelineItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TimelineItemID is the timelineItemID argument value.
			TimelineItemID string
		}
		// DevLogin holds details about calls to the DevLogin method.
		DevLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// Followees holds details about calls to the Followees method.
		Followees []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// Followers holds details about calls to the Followers method.
		Followers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// HasUnreadNotifications holds details about calls to the HasUnreadNotifications method.
		HasUnreadNotifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// MarkNotificationAsRead holds details about calls to the MarkNotificationAsRead method.
		MarkNotificationAsRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NotificationID is the notificationID argument value.
			NotificationID string
		}
		// MarkNotificationsAsRead holds details about calls to the MarkNotificationsAsRead method.
		MarkNotificationsAsRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// NotificationStream holds details about calls to the NotificationStream method.
		NotificationStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Notifications holds details about calls to the Notifications method.
		Notifications []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// ParseRedirectURI holds details about calls to the ParseRedirectURI method.
		ParseRedirectURI []struct {
			// Rawurl is the rawurl argument value.
			Rawurl string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// Posts holds details about calls to the Posts method.
		Posts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// RegisterCredential holds details about calls to the RegisterCredential method.
		RegisterCredential []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data webauthn.SessionData
			// ParsedReply is the parsedReply argument value.
			ParsedReply *protocol.ParsedCredentialCreationData
		}
		// SendMagicLink holds details about calls to the SendMagicLink method.
		SendMagicLink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// RedirectURI is the redirectURI argument value.
			RedirectURI string
		}
		// Timeline holds details about calls to the Timeline method.
		Timeline []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Last is the last argument value.
			Last uint64
			// Before is the before argument value.
			Before *string
		}
		// TimelineItemStream holds details about calls to the TimelineItemStream method.
		TimelineItemStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ToggleCommentLike holds details about calls to the ToggleCommentLike method.
		ToggleCommentLike []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CommentID is the commentID argument value.
			CommentID string
		}
		// ToggleFollow holds details about calls to the ToggleFollow method.
		ToggleFollow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// TogglePostLike holds details about calls to the TogglePostLike method.
		TogglePostLike []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// TogglePostSubscription holds details about calls to the TogglePostSubscription method.
		TogglePostSubscription []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PostID is the postID argument value.
			PostID string
		}
		// Token holds details about calls to the Token method.
		Token []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateAvatar holds details about calls to the UpdateAvatar method.
		UpdateAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R io.Reader
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params nakama.UpdateUserParams
		}
		// User holds details about calls to the User method.
		User []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// Usernames holds details about calls to the Usernames method.
		Usernames []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StartingWith is the startingWith argument value.
			StartingWith string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// Users holds details about calls to the Users method.
		Users []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Search is the search argument value.
			Search string
			// First is the first argument value.
			First uint64
			// After is the after argument value.
			After *string
		}
		// VerifyMagicLink holds details about calls to the VerifyMagicLink method.
		VerifyMagicLink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Code is the code argument value.
			Code string
			// Username is the username argument value.
			Username *string
		}
		// WebAuthnLogin holds details about calls to the WebAuthnLogin method.
		WebAuthnLogin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data webauthn.SessionData
			// Reply is the reply argument value.
			Reply *protocol.ParsedCredentialAssertionData
		}
	}
	lockAuthUser                  sync.RWMutex
	lockAuthUserIDFromToken       sync.RWMutex
	lockCommentStream             sync.RWMutex
	lockComments                  sync.RWMutex
	lockCreateComment             sync.RWMutex
	lockCreateTimelineItem        sync.RWMutex
	lockCredentialCreationOptions sync.RWMutex
	lockCredentialRequestOptions  sync.RWMutex
	lockDeletePost                sync.RWMutex
	lockDeleteTimelineItem        sync.RWMutex
	lockDevLogin                  sync.RWMutex
	lockFollowees                 sync.RWMutex
	lockFollowers                 sync.RWMutex
	lockHasUnreadNotifications    sync.RWMutex
	lockMarkNotificationAsRead    sync.RWMutex
	lockMarkNotificationsAsRead   sync.RWMutex
	lockNotificationStream        sync.RWMutex
	lockNotifications             sync.RWMutex
	lockParseRedirectURI          sync.RWMutex
	lockPost                      sync.RWMutex
	lockPosts                     sync.RWMutex
	lockRegisterCredential        sync.RWMutex
	lockSendMagicLink             sync.RWMutex
	lockTimeline                  sync.RWMutex
	lockTimelineItemStream        sync.RWMutex
	lockToggleCommentLike         sync.RWMutex
	lockToggleFollow              sync.RWMutex
	lockTogglePostLike            sync.RWMutex
	lockTogglePostSubscription    sync.RWMutex
	lockToken                     sync.RWMutex
	lockUpdateAvatar              sync.RWMutex
	lockUpdateUser                sync.RWMutex
	lockUser                      sync.RWMutex
	lockUsernames                 sync.RWMutex
	lockUsers                     sync.RWMutex
	lockVerifyMagicLink           sync.RWMutex
	lockWebAuthnLogin             sync.RWMutex
}

// AuthUser calls AuthUserFunc.
func (mock *ServiceMock) AuthUser(ctx context.Context) (nakama.User, error) {
	if mock.AuthUserFunc == nil {
		panic("ServiceMock.AuthUserFunc: method is nil but Service.AuthUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockAuthUser.Lock()
	mock.calls.AuthUser = append(mock.calls.AuthUser, callInfo)
	mock.lockAuthUser.Unlock()
	return mock.AuthUserFunc(ctx)
}

// AuthUserCalls gets all the calls that were made to AuthUser.
// Check the length with:
//     len(mockedService.AuthUserCalls())
func (mock *ServiceMock) AuthUserCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockAuthUser.RLock()
	calls = mock.calls.AuthUser
	mock.lockAuthUser.RUnlock()
	return calls
}

// AuthUserIDFromToken calls AuthUserIDFromTokenFunc.
func (mock *ServiceMock) AuthUserIDFromToken(token string) (string, error) {
	if mock.AuthUserIDFromTokenFunc == nil {
		panic("ServiceMock.AuthUserIDFromTokenFunc: method is nil but Service.AuthUserIDFromToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	mock.lockAuthUserIDFromToken.Lock()
	mock.calls.AuthUserIDFromToken = append(mock.calls.AuthUserIDFromToken, callInfo)
	mock.lockAuthUserIDFromToken.Unlock()
	return mock.AuthUserIDFromTokenFunc(token)
}

// AuthUserIDFromTokenCalls gets all the calls that were made to AuthUserIDFromToken.
// Check the length with:
//     len(mockedService.AuthUserIDFromTokenCalls())
func (mock *ServiceMock) AuthUserIDFromTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	mock.lockAuthUserIDFromToken.RLock()
	calls = mock.calls.AuthUserIDFromToken
	mock.lockAuthUserIDFromToken.RUnlock()
	return calls
}

// CommentStream calls CommentStreamFunc.
func (mock *ServiceMock) CommentStream(ctx context.Context, postID string) (<-chan nakama.Comment, error) {
	if mock.CommentStreamFunc == nil {
		panic("ServiceMock.CommentStreamFunc: method is nil but Service.CommentStream was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockCommentStream.Lock()
	mock.calls.CommentStream = append(mock.calls.CommentStream, callInfo)
	mock.lockCommentStream.Unlock()
	return mock.CommentStreamFunc(ctx, postID)
}

// CommentStreamCalls gets all the calls that were made to CommentStream.
// Check the length with:
//     len(mockedService.CommentStreamCalls())
func (mock *ServiceMock) CommentStreamCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockCommentStream.RLock()
	calls = mock.calls.CommentStream
	mock.lockCommentStream.RUnlock()
	return calls
}

// Comments calls CommentsFunc.
func (mock *ServiceMock) Comments(ctx context.Context, postID string, last uint64, before *string) (nakama.Comments, error) {
	if mock.CommentsFunc == nil {
		panic("ServiceMock.CommentsFunc: method is nil but Service.Comments was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		PostID: postID,
		Last:   last,
		Before: before,
	}
	mock.lockComments.Lock()
	mock.calls.Comments = append(mock.calls.Comments, callInfo)
	mock.lockComments.Unlock()
	return mock.CommentsFunc(ctx, postID, last, before)
}

// CommentsCalls gets all the calls that were made to Comments.
// Check the length with:
//     len(mockedService.CommentsCalls())
func (mock *ServiceMock) CommentsCalls() []struct {
	Ctx    context.Context
	PostID string
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
		Last   uint64
		Before *string
	}
	mock.lockComments.RLock()
	calls = mock.calls.Comments
	mock.lockComments.RUnlock()
	return calls
}

// CreateComment calls CreateCommentFunc.
func (mock *ServiceMock) CreateComment(ctx context.Context, postID string, content string) (nakama.Comment, error) {
	if mock.CreateCommentFunc == nil {
		panic("ServiceMock.CreateCommentFunc: method is nil but Service.CreateComment was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		PostID  string
		Content string
	}{
		Ctx:     ctx,
		PostID:  postID,
		Content: content,
	}
	mock.lockCreateComment.Lock()
	mock.calls.CreateComment = append(mock.calls.CreateComment, callInfo)
	mock.lockCreateComment.Unlock()
	return mock.CreateCommentFunc(ctx, postID, content)
}

// CreateCommentCalls gets all the calls that were made to CreateComment.
// Check the length with:
//     len(mockedService.CreateCommentCalls())
func (mock *ServiceMock) CreateCommentCalls() []struct {
	Ctx     context.Context
	PostID  string
	Content string
} {
	var calls []struct {
		Ctx     context.Context
		PostID  string
		Content string
	}
	mock.lockCreateComment.RLock()
	calls = mock.calls.CreateComment
	mock.lockCreateComment.RUnlock()
	return calls
}

// CreateTimelineItem calls CreateTimelineItemFunc.
func (mock *ServiceMock) CreateTimelineItem(ctx context.Context, content string, spoilerOf *string, nsfw bool) (nakama.TimelineItem, error) {
	if mock.CreateTimelineItemFunc == nil {
		panic("ServiceMock.CreateTimelineItemFunc: method is nil but Service.CreateTimelineItem was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Content   string
		SpoilerOf *string
		Nsfw      bool
	}{
		Ctx:       ctx,
		Content:   content,
		SpoilerOf: spoilerOf,
		Nsfw:      nsfw,
	}
	mock.lockCreateTimelineItem.Lock()
	mock.calls.CreateTimelineItem = append(mock.calls.CreateTimelineItem, callInfo)
	mock.lockCreateTimelineItem.Unlock()
	return mock.CreateTimelineItemFunc(ctx, content, spoilerOf, nsfw)
}

// CreateTimelineItemCalls gets all the calls that were made to CreateTimelineItem.
// Check the length with:
//     len(mockedService.CreateTimelineItemCalls())
func (mock *ServiceMock) CreateTimelineItemCalls() []struct {
	Ctx       context.Context
	Content   string
	SpoilerOf *string
	Nsfw      bool
} {
	var calls []struct {
		Ctx       context.Context
		Content   string
		SpoilerOf *string
		Nsfw      bool
	}
	mock.lockCreateTimelineItem.RLock()
	calls = mock.calls.CreateTimelineItem
	mock.lockCreateTimelineItem.RUnlock()
	return calls
}

// CredentialCreationOptions calls CredentialCreationOptionsFunc.
func (mock *ServiceMock) CredentialCreationOptions(ctx context.Context) (*protocol.CredentialCreation, *webauthn.SessionData, error) {
	if mock.CredentialCreationOptionsFunc == nil {
		panic("ServiceMock.CredentialCreationOptionsFunc: method is nil but Service.CredentialCreationOptions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCredentialCreationOptions.Lock()
	mock.calls.CredentialCreationOptions = append(mock.calls.CredentialCreationOptions, callInfo)
	mock.lockCredentialCreationOptions.Unlock()
	return mock.CredentialCreationOptionsFunc(ctx)
}

// CredentialCreationOptionsCalls gets all the calls that were made to CredentialCreationOptions.
// Check the length with:
//     len(mockedService.CredentialCreationOptionsCalls())
func (mock *ServiceMock) CredentialCreationOptionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCredentialCreationOptions.RLock()
	calls = mock.calls.CredentialCreationOptions
	mock.lockCredentialCreationOptions.RUnlock()
	return calls
}

// CredentialRequestOptions calls CredentialRequestOptionsFunc.
func (mock *ServiceMock) CredentialRequestOptions(ctx context.Context, email string, opts ...nakama.CredentialRequestOptionsOpt) (*protocol.CredentialAssertion, *webauthn.SessionData, error) {
	if mock.CredentialRequestOptionsFunc == nil {
		panic("ServiceMock.CredentialRequestOptionsFunc: method is nil but Service.CredentialRequestOptions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
		Opts  []nakama.CredentialRequestOptionsOpt
	}{
		Ctx:   ctx,
		Email: email,
		Opts:  opts,
	}
	mock.lockCredentialRequestOptions.Lock()
	mock.calls.CredentialRequestOptions = append(mock.calls.CredentialRequestOptions, callInfo)
	mock.lockCredentialRequestOptions.Unlock()
	return mock.CredentialRequestOptionsFunc(ctx, email, opts...)
}

// CredentialRequestOptionsCalls gets all the calls that were made to CredentialRequestOptions.
// Check the length with:
//     len(mockedService.CredentialRequestOptionsCalls())
func (mock *ServiceMock) CredentialRequestOptionsCalls() []struct {
	Ctx   context.Context
	Email string
	Opts  []nakama.CredentialRequestOptionsOpt
} {
	var calls []struct {
		Ctx   context.Context
		Email string
		Opts  []nakama.CredentialRequestOptionsOpt
	}
	mock.lockCredentialRequestOptions.RLock()
	calls = mock.calls.CredentialRequestOptions
	mock.lockCredentialRequestOptions.RUnlock()
	return calls
}

// DeletePost calls DeletePostFunc.
func (mock *ServiceMock) DeletePost(ctx context.Context, postID string) error {
	if mock.DeletePostFunc == nil {
		panic("ServiceMock.DeletePostFunc: method is nil but Service.DeletePost was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockDeletePost.Lock()
	mock.calls.DeletePost = append(mock.calls.DeletePost, callInfo)
	mock.lockDeletePost.Unlock()
	return mock.DeletePostFunc(ctx, postID)
}

// DeletePostCalls gets all the calls that were made to DeletePost.
// Check the length with:
//     len(mockedService.DeletePostCalls())
func (mock *ServiceMock) DeletePostCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockDeletePost.RLock()
	calls = mock.calls.DeletePost
	mock.lockDeletePost.RUnlock()
	return calls
}

// DeleteTimelineItem calls DeleteTimelineItemFunc.
func (mock *ServiceMock) DeleteTimelineItem(ctx context.Context, timelineItemID string) error {
	if mock.DeleteTimelineItemFunc == nil {
		panic("ServiceMock.DeleteTimelineItemFunc: method is nil but Service.DeleteTimelineItem was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		TimelineItemID string
	}{
		Ctx:            ctx,
		TimelineItemID: timelineItemID,
	}
	mock.lockDeleteTimelineItem.Lock()
	mock.calls.DeleteTimelineItem = append(mock.calls.DeleteTimelineItem, callInfo)
	mock.lockDeleteTimelineItem.Unlock()
	return mock.DeleteTimelineItemFunc(ctx, timelineItemID)
}

// DeleteTimelineItemCalls gets all the calls that were made to DeleteTimelineItem.
// Check the length with:
//     len(mockedService.DeleteTimelineItemCalls())
func (mock *ServiceMock) DeleteTimelineItemCalls() []struct {
	Ctx            context.Context
	TimelineItemID string
} {
	var calls []struct {
		Ctx            context.Context
		TimelineItemID string
	}
	mock.lockDeleteTimelineItem.RLock()
	calls = mock.calls.DeleteTimelineItem
	mock.lockDeleteTimelineItem.RUnlock()
	return calls
}

// DevLogin calls DevLoginFunc.
func (mock *ServiceMock) DevLogin(ctx context.Context, email string) (nakama.AuthOutput, error) {
	if mock.DevLoginFunc == nil {
		panic("ServiceMock.DevLoginFunc: method is nil but Service.DevLogin was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockDevLogin.Lock()
	mock.calls.DevLogin = append(mock.calls.DevLogin, callInfo)
	mock.lockDevLogin.Unlock()
	return mock.DevLoginFunc(ctx, email)
}

// DevLoginCalls gets all the calls that were made to DevLogin.
// Check the length with:
//     len(mockedService.DevLoginCalls())
func (mock *ServiceMock) DevLoginCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockDevLogin.RLock()
	calls = mock.calls.DevLogin
	mock.lockDevLogin.RUnlock()
	return calls
}

// Followees calls FolloweesFunc.
func (mock *ServiceMock) Followees(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
	if mock.FolloweesFunc == nil {
		panic("ServiceMock.FolloweesFunc: method is nil but Service.Followees was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}{
		Ctx:      ctx,
		Username: username,
		First:    first,
		After:    after,
	}
	mock.lockFollowees.Lock()
	mock.calls.Followees = append(mock.calls.Followees, callInfo)
	mock.lockFollowees.Unlock()
	return mock.FolloweesFunc(ctx, username, first, after)
}

// FolloweesCalls gets all the calls that were made to Followees.
// Check the length with:
//     len(mockedService.FolloweesCalls())
func (mock *ServiceMock) FolloweesCalls() []struct {
	Ctx      context.Context
	Username string
	First    uint64
	After    *string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}
	mock.lockFollowees.RLock()
	calls = mock.calls.Followees
	mock.lockFollowees.RUnlock()
	return calls
}

// Followers calls FollowersFunc.
func (mock *ServiceMock) Followers(ctx context.Context, username string, first uint64, after *string) (nakama.UserProfiles, error) {
	if mock.FollowersFunc == nil {
		panic("ServiceMock.FollowersFunc: method is nil but Service.Followers was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}{
		Ctx:      ctx,
		Username: username,
		First:    first,
		After:    after,
	}
	mock.lockFollowers.Lock()
	mock.calls.Followers = append(mock.calls.Followers, callInfo)
	mock.lockFollowers.Unlock()
	return mock.FollowersFunc(ctx, username, first, after)
}

// FollowersCalls gets all the calls that were made to Followers.
// Check the length with:
//     len(mockedService.FollowersCalls())
func (mock *ServiceMock) FollowersCalls() []struct {
	Ctx      context.Context
	Username string
	First    uint64
	After    *string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		First    uint64
		After    *string
	}
	mock.lockFollowers.RLock()
	calls = mock.calls.Followers
	mock.lockFollowers.RUnlock()
	return calls
}

// HasUnreadNotifications calls HasUnreadNotificationsFunc.
func (mock *ServiceMock) HasUnreadNotifications(ctx context.Context) (bool, error) {
	if mock.HasUnreadNotificationsFunc == nil {
		panic("ServiceMock.HasUnreadNotificationsFunc: method is nil but Service.HasUnreadNotifications was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHasUnreadNotifications.Lock()
	mock.calls.HasUnreadNotifications = append(mock.calls.HasUnreadNotifications, callInfo)
	mock.lockHasUnreadNotifications.Unlock()
	return mock.HasUnreadNotificationsFunc(ctx)
}

// HasUnreadNotificationsCalls gets all the calls that were made to HasUnreadNotifications.
// Check the length with:
//     len(mockedService.HasUnreadNotificationsCalls())
func (mock *ServiceMock) HasUnreadNotificationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHasUnreadNotifications.RLock()
	calls = mock.calls.HasUnreadNotifications
	mock.lockHasUnreadNotifications.RUnlock()
	return calls
}

// MarkNotificationAsRead calls MarkNotificationAsReadFunc.
func (mock *ServiceMock) MarkNotificationAsRead(ctx context.Context, notificationID string) error {
	if mock.MarkNotificationAsReadFunc == nil {
		panic("ServiceMock.MarkNotificationAsReadFunc: method is nil but Service.MarkNotificationAsRead was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		NotificationID string
	}{
		Ctx:            ctx,
		NotificationID: notificationID,
	}
	mock.lockMarkNotificationAsRead.Lock()
	mock.calls.MarkNotificationAsRead = append(mock.calls.MarkNotificationAsRead, callInfo)
	mock.lockMarkNotificationAsRead.Unlock()
	return mock.MarkNotificationAsReadFunc(ctx, notificationID)
}

// MarkNotificationAsReadCalls gets all the calls that were made to MarkNotificationAsRead.
// Check the length with:
//     len(mockedService.MarkNotificationAsReadCalls())
func (mock *ServiceMock) MarkNotificationAsReadCalls() []struct {
	Ctx            context.Context
	NotificationID string
} {
	var calls []struct {
		Ctx            context.Context
		NotificationID string
	}
	mock.lockMarkNotificationAsRead.RLock()
	calls = mock.calls.MarkNotificationAsRead
	mock.lockMarkNotificationAsRead.RUnlock()
	return calls
}

// MarkNotificationsAsRead calls MarkNotificationsAsReadFunc.
func (mock *ServiceMock) MarkNotificationsAsRead(ctx context.Context) error {
	if mock.MarkNotificationsAsReadFunc == nil {
		panic("ServiceMock.MarkNotificationsAsReadFunc: method is nil but Service.MarkNotificationsAsRead was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockMarkNotificationsAsRead.Lock()
	mock.calls.MarkNotificationsAsRead = append(mock.calls.MarkNotificationsAsRead, callInfo)
	mock.lockMarkNotificationsAsRead.Unlock()
	return mock.MarkNotificationsAsReadFunc(ctx)
}

// MarkNotificationsAsReadCalls gets all the calls that were made to MarkNotificationsAsRead.
// Check the length with:
//     len(mockedService.MarkNotificationsAsReadCalls())
func (mock *ServiceMock) MarkNotificationsAsReadCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockMarkNotificationsAsRead.RLock()
	calls = mock.calls.MarkNotificationsAsRead
	mock.lockMarkNotificationsAsRead.RUnlock()
	return calls
}

// NotificationStream calls NotificationStreamFunc.
func (mock *ServiceMock) NotificationStream(ctx context.Context) (<-chan nakama.Notification, error) {
	if mock.NotificationStreamFunc == nil {
		panic("ServiceMock.NotificationStreamFunc: method is nil but Service.NotificationStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNotificationStream.Lock()
	mock.calls.NotificationStream = append(mock.calls.NotificationStream, callInfo)
	mock.lockNotificationStream.Unlock()
	return mock.NotificationStreamFunc(ctx)
}

// NotificationStreamCalls gets all the calls that were made to NotificationStream.
// Check the length with:
//     len(mockedService.NotificationStreamCalls())
func (mock *ServiceMock) NotificationStreamCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNotificationStream.RLock()
	calls = mock.calls.NotificationStream
	mock.lockNotificationStream.RUnlock()
	return calls
}

// Notifications calls NotificationsFunc.
func (mock *ServiceMock) Notifications(ctx context.Context, last uint64, before *string) (nakama.Notifications, error) {
	if mock.NotificationsFunc == nil {
		panic("ServiceMock.NotificationsFunc: method is nil but Service.Notifications was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		Last:   last,
		Before: before,
	}
	mock.lockNotifications.Lock()
	mock.calls.Notifications = append(mock.calls.Notifications, callInfo)
	mock.lockNotifications.Unlock()
	return mock.NotificationsFunc(ctx, last, before)
}

// NotificationsCalls gets all the calls that were made to Notifications.
// Check the length with:
//     len(mockedService.NotificationsCalls())
func (mock *ServiceMock) NotificationsCalls() []struct {
	Ctx    context.Context
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}
	mock.lockNotifications.RLock()
	calls = mock.calls.Notifications
	mock.lockNotifications.RUnlock()
	return calls
}

// ParseRedirectURI calls ParseRedirectURIFunc.
func (mock *ServiceMock) ParseRedirectURI(rawurl string) (*url.URL, error) {
	if mock.ParseRedirectURIFunc == nil {
		panic("ServiceMock.ParseRedirectURIFunc: method is nil but Service.ParseRedirectURI was just called")
	}
	callInfo := struct {
		Rawurl string
	}{
		Rawurl: rawurl,
	}
	mock.lockParseRedirectURI.Lock()
	mock.calls.ParseRedirectURI = append(mock.calls.ParseRedirectURI, callInfo)
	mock.lockParseRedirectURI.Unlock()
	return mock.ParseRedirectURIFunc(rawurl)
}

// ParseRedirectURICalls gets all the calls that were made to ParseRedirectURI.
// Check the length with:
//     len(mockedService.ParseRedirectURICalls())
func (mock *ServiceMock) ParseRedirectURICalls() []struct {
	Rawurl string
} {
	var calls []struct {
		Rawurl string
	}
	mock.lockParseRedirectURI.RLock()
	calls = mock.calls.ParseRedirectURI
	mock.lockParseRedirectURI.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *ServiceMock) Post(ctx context.Context, postID string) (nakama.Post, error) {
	if mock.PostFunc == nil {
		panic("ServiceMock.PostFunc: method is nil but Service.Post was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	mock.lockPost.Unlock()
	return mock.PostFunc(ctx, postID)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//     len(mockedService.PostCalls())
func (mock *ServiceMock) PostCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockPost.RLock()
	calls = mock.calls.Post
	mock.lockPost.RUnlock()
	return calls
}

// Posts calls PostsFunc.
func (mock *ServiceMock) Posts(ctx context.Context, username string, last uint64, before *string) (nakama.Posts, error) {
	if mock.PostsFunc == nil {
		panic("ServiceMock.PostsFunc: method is nil but Service.Posts was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		Last     uint64
		Before   *string
	}{
		Ctx:      ctx,
		Username: username,
		Last:     last,
		Before:   before,
	}
	mock.lockPosts.Lock()
	mock.calls.Posts = append(mock.calls.Posts, callInfo)
	mock.lockPosts.Unlock()
	return mock.PostsFunc(ctx, username, last, before)
}

// PostsCalls gets all the calls that were made to Posts.
// Check the length with:
//     len(mockedService.PostsCalls())
func (mock *ServiceMock) PostsCalls() []struct {
	Ctx      context.Context
	Username string
	Last     uint64
	Before   *string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		Last     uint64
		Before   *string
	}
	mock.lockPosts.RLock()
	calls = mock.calls.Posts
	mock.lockPosts.RUnlock()
	return calls
}

// RegisterCredential calls RegisterCredentialFunc.
func (mock *ServiceMock) RegisterCredential(ctx context.Context, data webauthn.SessionData, parsedReply *protocol.ParsedCredentialCreationData) error {
	if mock.RegisterCredentialFunc == nil {
		panic("ServiceMock.RegisterCredentialFunc: method is nil but Service.RegisterCredential was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Data        webauthn.SessionData
		ParsedReply *protocol.ParsedCredentialCreationData
	}{
		Ctx:         ctx,
		Data:        data,
		ParsedReply: parsedReply,
	}
	mock.lockRegisterCredential.Lock()
	mock.calls.RegisterCredential = append(mock.calls.RegisterCredential, callInfo)
	mock.lockRegisterCredential.Unlock()
	return mock.RegisterCredentialFunc(ctx, data, parsedReply)
}

// RegisterCredentialCalls gets all the calls that were made to RegisterCredential.
// Check the length with:
//     len(mockedService.RegisterCredentialCalls())
func (mock *ServiceMock) RegisterCredentialCalls() []struct {
	Ctx         context.Context
	Data        webauthn.SessionData
	ParsedReply *protocol.ParsedCredentialCreationData
} {
	var calls []struct {
		Ctx         context.Context
		Data        webauthn.SessionData
		ParsedReply *protocol.ParsedCredentialCreationData
	}
	mock.lockRegisterCredential.RLock()
	calls = mock.calls.RegisterCredential
	mock.lockRegisterCredential.RUnlock()
	return calls
}

// SendMagicLink calls SendMagicLinkFunc.
func (mock *ServiceMock) SendMagicLink(ctx context.Context, email string, redirectURI string) error {
	if mock.SendMagicLinkFunc == nil {
		panic("ServiceMock.SendMagicLinkFunc: method is nil but Service.SendMagicLink was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Email       string
		RedirectURI string
	}{
		Ctx:         ctx,
		Email:       email,
		RedirectURI: redirectURI,
	}
	mock.lockSendMagicLink.Lock()
	mock.calls.SendMagicLink = append(mock.calls.SendMagicLink, callInfo)
	mock.lockSendMagicLink.Unlock()
	return mock.SendMagicLinkFunc(ctx, email, redirectURI)
}

// SendMagicLinkCalls gets all the calls that were made to SendMagicLink.
// Check the length with:
//     len(mockedService.SendMagicLinkCalls())
func (mock *ServiceMock) SendMagicLinkCalls() []struct {
	Ctx         context.Context
	Email       string
	RedirectURI string
} {
	var calls []struct {
		Ctx         context.Context
		Email       string
		RedirectURI string
	}
	mock.lockSendMagicLink.RLock()
	calls = mock.calls.SendMagicLink
	mock.lockSendMagicLink.RUnlock()
	return calls
}

// Timeline calls TimelineFunc.
func (mock *ServiceMock) Timeline(ctx context.Context, last uint64, before *string) (nakama.Timeline, error) {
	if mock.TimelineFunc == nil {
		panic("ServiceMock.TimelineFunc: method is nil but Service.Timeline was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}{
		Ctx:    ctx,
		Last:   last,
		Before: before,
	}
	mock.lockTimeline.Lock()
	mock.calls.Timeline = append(mock.calls.Timeline, callInfo)
	mock.lockTimeline.Unlock()
	return mock.TimelineFunc(ctx, last, before)
}

// TimelineCalls gets all the calls that were made to Timeline.
// Check the length with:
//     len(mockedService.TimelineCalls())
func (mock *ServiceMock) TimelineCalls() []struct {
	Ctx    context.Context
	Last   uint64
	Before *string
} {
	var calls []struct {
		Ctx    context.Context
		Last   uint64
		Before *string
	}
	mock.lockTimeline.RLock()
	calls = mock.calls.Timeline
	mock.lockTimeline.RUnlock()
	return calls
}

// TimelineItemStream calls TimelineItemStreamFunc.
func (mock *ServiceMock) TimelineItemStream(ctx context.Context) (<-chan nakama.TimelineItem, error) {
	if mock.TimelineItemStreamFunc == nil {
		panic("ServiceMock.TimelineItemStreamFunc: method is nil but Service.TimelineItemStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockTimelineItemStream.Lock()
	mock.calls.TimelineItemStream = append(mock.calls.TimelineItemStream, callInfo)
	mock.lockTimelineItemStream.Unlock()
	return mock.TimelineItemStreamFunc(ctx)
}

// TimelineItemStreamCalls gets all the calls that were made to TimelineItemStream.
// Check the length with:
//     len(mockedService.TimelineItemStreamCalls())
func (mock *ServiceMock) TimelineItemStreamCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockTimelineItemStream.RLock()
	calls = mock.calls.TimelineItemStream
	mock.lockTimelineItemStream.RUnlock()
	return calls
}

// ToggleCommentLike calls ToggleCommentLikeFunc.
func (mock *ServiceMock) ToggleCommentLike(ctx context.Context, commentID string) (nakama.ToggleLikeOutput, error) {
	if mock.ToggleCommentLikeFunc == nil {
		panic("ServiceMock.ToggleCommentLikeFunc: method is nil but Service.ToggleCommentLike was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		CommentID string
	}{
		Ctx:       ctx,
		CommentID: commentID,
	}
	mock.lockToggleCommentLike.Lock()
	mock.calls.ToggleCommentLike = append(mock.calls.ToggleCommentLike, callInfo)
	mock.lockToggleCommentLike.Unlock()
	return mock.ToggleCommentLikeFunc(ctx, commentID)
}

// ToggleCommentLikeCalls gets all the calls that were made to ToggleCommentLike.
// Check the length with:
//     len(mockedService.ToggleCommentLikeCalls())
func (mock *ServiceMock) ToggleCommentLikeCalls() []struct {
	Ctx       context.Context
	CommentID string
} {
	var calls []struct {
		Ctx       context.Context
		CommentID string
	}
	mock.lockToggleCommentLike.RLock()
	calls = mock.calls.ToggleCommentLike
	mock.lockToggleCommentLike.RUnlock()
	return calls
}

// ToggleFollow calls ToggleFollowFunc.
func (mock *ServiceMock) ToggleFollow(ctx context.Context, username string) (nakama.ToggleFollowOutput, error) {
	if mock.ToggleFollowFunc == nil {
		panic("ServiceMock.ToggleFollowFunc: method is nil but Service.ToggleFollow was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockToggleFollow.Lock()
	mock.calls.ToggleFollow = append(mock.calls.ToggleFollow, callInfo)
	mock.lockToggleFollow.Unlock()
	return mock.ToggleFollowFunc(ctx, username)
}

// ToggleFollowCalls gets all the calls that were made to ToggleFollow.
// Check the length with:
//     len(mockedService.ToggleFollowCalls())
func (mock *ServiceMock) ToggleFollowCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockToggleFollow.RLock()
	calls = mock.calls.ToggleFollow
	mock.lockToggleFollow.RUnlock()
	return calls
}

// TogglePostLike calls TogglePostLikeFunc.
func (mock *ServiceMock) TogglePostLike(ctx context.Context, postID string) (nakama.ToggleLikeOutput, error) {
	if mock.TogglePostLikeFunc == nil {
		panic("ServiceMock.TogglePostLikeFunc: method is nil but Service.TogglePostLike was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockTogglePostLike.Lock()
	mock.calls.TogglePostLike = append(mock.calls.TogglePostLike, callInfo)
	mock.lockTogglePostLike.Unlock()
	return mock.TogglePostLikeFunc(ctx, postID)
}

// TogglePostLikeCalls gets all the calls that were made to TogglePostLike.
// Check the length with:
//     len(mockedService.TogglePostLikeCalls())
func (mock *ServiceMock) TogglePostLikeCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockTogglePostLike.RLock()
	calls = mock.calls.TogglePostLike
	mock.lockTogglePostLike.RUnlock()
	return calls
}

// TogglePostSubscription calls TogglePostSubscriptionFunc.
func (mock *ServiceMock) TogglePostSubscription(ctx context.Context, postID string) (nakama.ToggleSubscriptionOutput, error) {
	if mock.TogglePostSubscriptionFunc == nil {
		panic("ServiceMock.TogglePostSubscriptionFunc: method is nil but Service.TogglePostSubscription was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PostID string
	}{
		Ctx:    ctx,
		PostID: postID,
	}
	mock.lockTogglePostSubscription.Lock()
	mock.calls.TogglePostSubscription = append(mock.calls.TogglePostSubscription, callInfo)
	mock.lockTogglePostSubscription.Unlock()
	return mock.TogglePostSubscriptionFunc(ctx, postID)
}

// TogglePostSubscriptionCalls gets all the calls that were made to TogglePostSubscription.
// Check the length with:
//     len(mockedService.TogglePostSubscriptionCalls())
func (mock *ServiceMock) TogglePostSubscriptionCalls() []struct {
	Ctx    context.Context
	PostID string
} {
	var calls []struct {
		Ctx    context.Context
		PostID string
	}
	mock.lockTogglePostSubscription.RLock()
	calls = mock.calls.TogglePostSubscription
	mock.lockTogglePostSubscription.RUnlock()
	return calls
}

// Token calls TokenFunc.
func (mock *ServiceMock) Token(ctx context.Context) (nakama.TokenOutput, error) {
	if mock.TokenFunc == nil {
		panic("ServiceMock.TokenFunc: method is nil but Service.Token was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockToken.Lock()
	mock.calls.Token = append(mock.calls.Token, callInfo)
	mock.lockToken.Unlock()
	return mock.TokenFunc(ctx)
}

// TokenCalls gets all the calls that were made to Token.
// Check the length with:
//     len(mockedService.TokenCalls())
func (mock *ServiceMock) TokenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockToken.RLock()
	calls = mock.calls.Token
	mock.lockToken.RUnlock()
	return calls
}

// UpdateAvatar calls UpdateAvatarFunc.
func (mock *ServiceMock) UpdateAvatar(ctx context.Context, r io.Reader) (string, error) {
	if mock.UpdateAvatarFunc == nil {
		panic("ServiceMock.UpdateAvatarFunc: method is nil but Service.UpdateAvatar was just called")
	}
	callInfo := struct {
		Ctx context.Context
		R   io.Reader
	}{
		Ctx: ctx,
		R:   r,
	}
	mock.lockUpdateAvatar.Lock()
	mock.calls.UpdateAvatar = append(mock.calls.UpdateAvatar, callInfo)
	mock.lockUpdateAvatar.Unlock()
	return mock.UpdateAvatarFunc(ctx, r)
}

// UpdateAvatarCalls gets all the calls that were made to UpdateAvatar.
// Check the length with:
//     len(mockedService.UpdateAvatarCalls())
func (mock *ServiceMock) UpdateAvatarCalls() []struct {
	Ctx context.Context
	R   io.Reader
} {
	var calls []struct {
		Ctx context.Context
		R   io.Reader
	}
	mock.lockUpdateAvatar.RLock()
	calls = mock.calls.UpdateAvatar
	mock.lockUpdateAvatar.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *ServiceMock) UpdateUser(ctx context.Context, params nakama.UpdateUserParams) (nakama.UpdatedUserFields, error) {
	if mock.UpdateUserFunc == nil {
		panic("ServiceMock.UpdateUserFunc: method is nil but Service.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params nakama.UpdateUserParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, params)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//     len(mockedService.UpdateUserCalls())
func (mock *ServiceMock) UpdateUserCalls() []struct {
	Ctx    context.Context
	Params nakama.UpdateUserParams
} {
	var calls []struct {
		Ctx    context.Context
		Params nakama.UpdateUserParams
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *ServiceMock) User(ctx context.Context, username string) (nakama.UserProfile, error) {
	if mock.UserFunc == nil {
		panic("ServiceMock.UserFunc: method is nil but Service.User was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc(ctx, username)
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//     len(mockedService.UserCalls())
func (mock *ServiceMock) UserCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}

// Usernames calls UsernamesFunc.
func (mock *ServiceMock) Usernames(ctx context.Context, startingWith string, first uint64, after *string) (nakama.Usernames, error) {
	if mock.UsernamesFunc == nil {
		panic("ServiceMock.UsernamesFunc: method is nil but Service.Usernames was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		StartingWith string
		First        uint64
		After        *string
	}{
		Ctx:          ctx,
		StartingWith: startingWith,
		First:        first,
		After:        after,
	}
	mock.lockUsernames.Lock()
	mock.calls.Usernames = append(mock.calls.Usernames, callInfo)
	mock.lockUsernames.Unlock()
	return mock.UsernamesFunc(ctx, startingWith, first, after)
}

// UsernamesCalls gets all the calls that were made to Usernames.
// Check the length with:
//     len(mockedService.UsernamesCalls())
func (mock *ServiceMock) UsernamesCalls() []struct {
	Ctx          context.Context
	StartingWith string
	First        uint64
	After        *string
} {
	var calls []struct {
		Ctx          context.Context
		StartingWith string
		First        uint64
		After        *string
	}
	mock.lockUsernames.RLock()
	calls = mock.calls.Usernames
	mock.lockUsernames.RUnlock()
	return calls
}

// Users calls UsersFunc.
func (mock *ServiceMock) Users(ctx context.Context, search string, first uint64, after *string) (nakama.UserProfiles, error) {
	if mock.UsersFunc == nil {
		panic("ServiceMock.UsersFunc: method is nil but Service.Users was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Search string
		First  uint64
		After  *string
	}{
		Ctx:    ctx,
		Search: search,
		First:  first,
		After:  after,
	}
	mock.lockUsers.Lock()
	mock.calls.Users = append(mock.calls.Users, callInfo)
	mock.lockUsers.Unlock()
	return mock.UsersFunc(ctx, search, first, after)
}

// UsersCalls gets all the calls that were made to Users.
// Check the length with:
//     len(mockedService.UsersCalls())
func (mock *ServiceMock) UsersCalls() []struct {
	Ctx    context.Context
	Search string
	First  uint64
	After  *string
} {
	var calls []struct {
		Ctx    context.Context
		Search string
		First  uint64
		After  *string
	}
	mock.lockUsers.RLock()
	calls = mock.calls.Users
	mock.lockUsers.RUnlock()
	return calls
}

// VerifyMagicLink calls VerifyMagicLinkFunc.
func (mock *ServiceMock) VerifyMagicLink(ctx context.Context, email string, code string, username *string) (nakama.AuthOutput, error) {
	if mock.VerifyMagicLinkFunc == nil {
		panic("ServiceMock.VerifyMagicLinkFunc: method is nil but Service.VerifyMagicLink was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Email    string
		Code     string
		Username *string
	}{
		Ctx:      ctx,
		Email:    email,
		Code:     code,
		Username: username,
	}
	mock.lockVerifyMagicLink.Lock()
	mock.calls.VerifyMagicLink = append(mock.calls.VerifyMagicLink, callInfo)
	mock.lockVerifyMagicLink.Unlock()
	return mock.VerifyMagicLinkFunc(ctx, email, code, username)
}

// VerifyMagicLinkCalls gets all the calls that were made to VerifyMagicLink.
// Check the length with:
//     len(mockedService.VerifyMagicLinkCalls())
func (mock *ServiceMock) VerifyMagicLinkCalls() []struct {
	Ctx      context.Context
	Email    string
	Code     string
	Username *string
} {
	var calls []struct {
		Ctx      context.Context
		Email    string
		Code     string
		Username *string
	}
	mock.lockVerifyMagicLink.RLock()
	calls = mock.calls.VerifyMagicLink
	mock.lockVerifyMagicLink.RUnlock()
	return calls
}

// WebAuthnLogin calls WebAuthnLoginFunc.
func (mock *ServiceMock) WebAuthnLogin(ctx context.Context, data webauthn.SessionData, reply *protocol.ParsedCredentialAssertionData) (nakama.AuthOutput, error) {
	if mock.WebAuthnLoginFunc == nil {
		panic("ServiceMock.WebAuthnLoginFunc: method is nil but Service.WebAuthnLogin was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Data  webauthn.SessionData
		Reply *protocol.ParsedCredentialAssertionData
	}{
		Ctx:   ctx,
		Data:  data,
		Reply: reply,
	}
	mock.lockWebAuthnLogin.Lock()
	mock.calls.WebAuthnLogin = append(mock.calls.WebAuthnLogin, callInfo)
	mock.lockWebAuthnLogin.Unlock()
	return mock.WebAuthnLoginFunc(ctx, data, reply)
}

// WebAuthnLoginCalls gets all the calls that were made to WebAuthnLogin.
// Check the length with:
//     len(mockedService.WebAuthnLoginCalls())
func (mock *ServiceMock) WebAuthnLoginCalls() []struct {
	Ctx   context.Context
	Data  webauthn.SessionData
	Reply *protocol.ParsedCredentialAssertionData
} {
	var calls []struct {
		Ctx   context.Context
		Data  webauthn.SessionData
		Reply *protocol.ParsedCredentialAssertionData
	}
	mock.lockWebAuthnLogin.RLock()
	calls = mock.calls.WebAuthnLogin
	mock.lockWebAuthnLogin.RUnlock()
	return calls
}
